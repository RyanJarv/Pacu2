# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2021-12-31T02:49:16+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Annotated, Any, List, Optional

from pydantic import BaseModel, Extra, Field, SecretStr


class ValidationException(BaseModel):
    __root__: Any


class InternalServerException(ValidationException):
    pass


class StringEmpty256(BaseModel):
    __root__: Annotated[str, Field(max_length=256, min_length=0, regex='.*\\S.*')]


class ResourceNotFoundException(ValidationException):
    pass


class ContainerProviderType(Enum):
    EKS = 'EKS'


class ClusterId(BaseModel):
    __root__: Annotated[
        str, Field(max_length=100, min_length=1, regex='^[0-9A-Za-z][A-Za-z0-9\\-_]*')
    ]


class JobRunState(Enum):
    PENDING = 'PENDING'
    SUBMITTED = 'SUBMITTED'
    RUNNING = 'RUNNING'
    FAILED = 'FAILED'
    CANCELLED = 'CANCELLED'
    CANCEL_PENDING = 'CANCEL_PENDING'
    COMPLETED = 'COMPLETED'


class EndpointType(BaseModel):
    __root__: Annotated[str, Field(max_length=64, min_length=1, regex='.*\\S.*')]


class EndpointState(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    TERMINATING = 'TERMINATING'
    TERMINATED = 'TERMINATED'
    TERMINATED_WITH_ERRORS = 'TERMINATED_WITH_ERRORS'


class VirtualClusterState(Enum):
    RUNNING = 'RUNNING'
    TERMINATING = 'TERMINATING'
    TERMINATED = 'TERMINATED'
    ARRESTED = 'ARRESTED'


class TagResourceResponse(BaseModel):
    pass


class UntagResourceResponse(TagResourceResponse):
    pass


class String128(BaseModel):
    __root__: Annotated[str, Field(max_length=128, min_length=1, regex='.*\\S.*')]


class ACMCertArn(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=2048,
            min_length=44,
            regex='^arn:(aws[a-zA-Z0-9-]*):acm:.+:(\\d{12}):certificate/.+$',
        ),
    ]


class ResourceIdString(BaseModel):
    __root__: Annotated[str, Field(max_length=64, min_length=1, regex='[0-9a-z]+')]


class CancelJobRunRequest(BaseModel):
    pass


class ClientToken(EndpointType):
    pass


class LogGroupName(BaseModel):
    __root__: Annotated[
        str, Field(max_length=512, min_length=1, regex='[\\.\\-_/#A-Za-z0-9]+')
    ]


class String256(BaseModel):
    __root__: Annotated[str, Field(max_length=256, min_length=1, regex='.*\\S.*')]


class CloudWatchMonitoringConfiguration(BaseModel):
    """
    A configuration for CloudWatch monitoring. You can configure your jobs to send log information to CloudWatch Logs.
    """

    logGroupName: LogGroupName
    logStreamNamePrefix: Optional[String256] = None


class String1024(BaseModel):
    __root__: Annotated[str, Field(max_length=1024, min_length=1, regex='.*\\S.*')]


class ResourceNameString(BaseModel):
    __root__: Annotated[
        str, Field(max_length=64, min_length=1, regex='[\\.\\-_/#A-Za-z0-9]+')
    ]


class ReleaseLabel(BaseModel):
    __root__: Annotated[
        str, Field(max_length=64, min_length=1, regex='[\\.\\-_/A-Za-z0-9]+')
    ]


class IAMRoleArn(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=2048,
            min_length=20,
            regex='^arn:(aws[a-zA-Z0-9-]*):iam::(\\d{12})?:(role((\\u002F)|(\\u002F[\\u0021-\\u007F]+\\u002F))[\\w+=,.@-]+)$',
        ),
    ]


class TagMap(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class EndpointArn(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=60,
            regex='^arn:(aws[a-zA-Z0-9-]*):emr-containers:.+:(\\d{12}):\\/virtualclusters\\/[0-9a-zA-Z]+\\/endpoints\\/[0-9a-zA-Z]+$',
        ),
    ]


class VirtualClusterArn(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=60,
            regex='^arn:(aws[a-zA-Z0-9-]*):emr-containers:.+:(\\d{12}):\\/virtualclusters\\/[0-9a-zA-Z]+$',
        ),
    ]


class Date(BaseModel):
    __root__: datetime


class DeleteManagedEndpointRequest(BaseModel):
    pass


class DeleteVirtualClusterRequest(BaseModel):
    pass


class DescribeJobRunRequest(BaseModel):
    pass


class DescribeManagedEndpointRequest(BaseModel):
    pass


class DescribeVirtualClusterRequest(BaseModel):
    pass


class KubernetesNamespace(BaseModel):
    __root__: Annotated[
        str, Field(max_length=63, min_length=1, regex='[a-z0-9]([-a-z0-9]*[a-z0-9])?')
    ]


class UriString(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=10280,
            min_length=1,
            regex='[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\r\\n\\t]*',
        ),
    ]


class SubnetIds(BaseModel):
    __root__: List[String256]


class FailureReason(Enum):
    INTERNAL_ERROR = 'INTERNAL_ERROR'
    USER_ERROR = 'USER_ERROR'
    VALIDATION_ERROR = 'VALIDATION_ERROR'
    CLUSTER_UNAVAILABLE = 'CLUSTER_UNAVAILABLE'


class EndpointStates(BaseModel):
    __root__: Annotated[List[EndpointState], Field(max_items=10)]


class EndpointTypes(BaseModel):
    __root__: Annotated[List[EndpointType], Field(max_items=10)]


class EntryPointArgument(BaseModel):
    __root__: Annotated[
        SecretStr,
        Field(
            max_length=10280,
            min_length=1,
            regex="(?!\\s*$)(^[^';|\\u0026\\u003C\\u003E*?`$(){}\\[\\]!#\\\\]*$)",
        ),
    ]


class EntryPointArguments(BaseModel):
    __root__: List[EntryPointArgument]


class EntryPointPath(BaseModel):
    __root__: Annotated[
        SecretStr,
        Field(
            max_length=256,
            min_length=1,
            regex="(?!\\s*$)(^[^';|\\u0026\\u003C\\u003E*?`$(){}\\[\\]!#\\\\]*$)",
        ),
    ]


class JavaInteger(BaseModel):
    __root__: int


class JobArn(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=60,
            regex='^arn:(aws[a-zA-Z0-9-]*):emr-containers:.+:(\\d{12}):\\/virtualclusters\\/[0-9a-zA-Z]+\\/jobruns\\/[0-9a-zA-Z]+$',
        ),
    ]


class RequestIdentityUserArn(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=2048,
            min_length=20,
            regex='^arn:(aws[a-zA-Z0-9-]*):(iam|sts)::(\\d{12})?:[\\w/+=,.@-]+$',
        ),
    ]


class JobRunStates(BaseModel):
    __root__: Annotated[List[JobRunState], Field(max_items=10)]


class NextToken(String1024):
    pass


class ListJobRunsRequest(BaseModel):
    pass


class ListManagedEndpointsRequest(BaseModel):
    pass


class RsiArn(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=500,
            min_length=60,
            regex='^arn:(aws[a-zA-Z0-9-]*):emr-containers:.+:(\\d{12}):/virtualclusters/.+$',
        ),
    ]


class ListTagsForResourceRequest(BaseModel):
    pass


class VirtualClusterStates(BaseModel):
    __root__: Annotated[List[VirtualClusterState], Field(max_items=10)]


class ListVirtualClustersRequest(BaseModel):
    pass


class PersistentAppUI(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class S3MonitoringConfiguration(BaseModel):
    """
    Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.
    """

    logUri: UriString


class SensitivePropertiesMap(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class SparkSubmitParameters(BaseModel):
    __root__: Annotated[
        SecretStr,
        Field(
            max_length=102400,
            min_length=1,
            regex="(?!\\s*$)(^[^';|\\u0026\\u003C\\u003E*?`$(){}\\[\\]!#\\\\]*$)",
        ),
    ]


class TagKeyList(BaseModel):
    __root__: Annotated[List[String128], Field(max_items=50, min_items=0)]


class TagResourceRequest(BaseModel):
    tags: TagMap


class UntagResourceRequest(BaseModel):
    pass


class CancelJobRunResponse(BaseModel):
    id: Optional[ResourceIdString] = None
    virtualClusterId: Optional[ResourceIdString] = None


class CreateManagedEndpointResponse(BaseModel):
    id: Optional[ResourceIdString] = None
    name: Optional[ResourceNameString] = None
    arn: Optional[EndpointArn] = None
    virtualClusterId: Optional[ResourceIdString] = None


class MonitoringConfiguration(BaseModel):
    """
    Configuration setting for monitoring.
    """

    persistentAppUI: Optional[PersistentAppUI] = None
    cloudWatchMonitoringConfiguration: Optional[
        CloudWatchMonitoringConfiguration
    ] = None
    s3MonitoringConfiguration: Optional[S3MonitoringConfiguration] = None


class CreateVirtualClusterResponse(BaseModel):
    id: Optional[ResourceIdString] = None
    name: Optional[ResourceNameString] = None
    arn: Optional[VirtualClusterArn] = None


class DeleteManagedEndpointResponse(CancelJobRunResponse):
    pass


class DeleteVirtualClusterResponse(BaseModel):
    id: Optional[ResourceIdString] = None


class ListTagsForResourceResponse(BaseModel):
    tags: Optional[TagMap] = None


class StartJobRunResponse(BaseModel):
    id: Optional[ResourceIdString] = None
    name: Optional[ResourceNameString] = None
    arn: Optional[JobArn] = None
    virtualClusterId: Optional[ResourceIdString] = None


class SparkSubmitJobDriver(BaseModel):
    """
    The information about job driver for Spark submit.
    """

    entryPoint: EntryPointPath
    entryPointArguments: Optional[EntryPointArguments] = None
    sparkSubmitParameters: Optional[SparkSubmitParameters] = None


class EksInfo(BaseModel):
    """
    The information about the EKS cluster.
    """

    namespace: Optional[KubernetesNamespace] = None


class JobDriver(BaseModel):
    """
    Specify the driver that the job runs on.
    """

    sparkSubmitJobDriver: Optional[SparkSubmitJobDriver] = None


class ContainerInfo(BaseModel):
    """
    The information about the container used for a job run or a managed endpoint.
    """

    eksInfo: Optional[EksInfo] = None


class ContainerProvider(BaseModel):
    """
    The information about the container provider.
    """

    type: ContainerProviderType
    id: ClusterId
    info: Optional[ContainerInfo] = None


class CreateVirtualClusterRequest(BaseModel):
    name: ResourceNameString
    containerProvider: ContainerProvider
    clientToken: ClientToken
    tags: Optional[TagMap] = None


class VirtualCluster(BaseModel):
    """
    This entity describes a virtual cluster. A virtual cluster is a Kubernetes namespace that Amazon EMR is registered with. Amazon EMR uses virtual clusters to run jobs and host endpoints. Multiple virtual clusters can be backed by the same physical cluster. However, each virtual cluster maps to one namespace on an EKS cluster. Virtual clusters do not create any active resources that contribute to your bill or that require lifecycle management outside the service.
    """

    id: Optional[ResourceIdString] = None
    name: Optional[ResourceNameString] = None
    arn: Optional[VirtualClusterArn] = None
    state: Optional[VirtualClusterState] = None
    containerProvider: Optional[ContainerProvider] = None
    createdAt: Optional[Date] = None
    tags: Optional[TagMap] = None


class VirtualClusters(BaseModel):
    __root__: List[VirtualCluster]


class DescribeVirtualClusterResponse(BaseModel):
    virtualCluster: Optional[VirtualCluster] = None


class ListVirtualClustersResponse(BaseModel):
    virtualClusters: Optional[VirtualClusters] = None
    nextToken: Optional[NextToken] = None


class ConfigurationList(BaseModel):
    __root__: Annotated[List[Configuration], Field(max_items=100)]


class DescribeJobRunResponse(BaseModel):
    jobRun: Optional[JobRun] = None


class DescribeManagedEndpointResponse(BaseModel):
    endpoint: Optional[Endpoint] = None


class ListJobRunsResponse(BaseModel):
    jobRuns: Optional[JobRuns] = None
    nextToken: Optional[NextToken] = None


class ListManagedEndpointsResponse(BaseModel):
    endpoints: Optional[Endpoints] = None
    nextToken: Optional[NextToken] = None


class Configuration(BaseModel):
    """
    A configuration specification to be used when provisioning virtual clusters, which can include configurations for applications and software bundled with Amazon EMR on EKS. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.
    """

    classification: String1024
    properties: Annotated[
        Optional[Any],
        Field(
            description='A set of properties specified within a configuration classification.'
        ),
    ] = None
    configurations: Optional[ConfigurationList] = None


class ConfigurationOverrides(BaseModel):
    """
    A configuration specification to be used to override existing configurations.
    """

    applicationConfiguration: Optional[ConfigurationList] = None
    monitoringConfiguration: Optional[MonitoringConfiguration] = None


class CreateManagedEndpointRequest(BaseModel):
    name: ResourceNameString
    type: EndpointType
    releaseLabel: ReleaseLabel
    executionRoleArn: IAMRoleArn
    certificateArn: ACMCertArn
    configurationOverrides: Optional[ConfigurationOverrides] = None
    clientToken: ClientToken
    tags: Optional[TagMap] = None


class JobRun(BaseModel):
    """
    This entity describes a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    """

    id: Optional[ResourceIdString] = None
    name: Optional[ResourceNameString] = None
    virtualClusterId: Optional[ResourceIdString] = None
    arn: Optional[JobArn] = None
    state: Optional[JobRunState] = None
    clientToken: Optional[ClientToken] = None
    executionRoleArn: Optional[IAMRoleArn] = None
    releaseLabel: Optional[ReleaseLabel] = None
    configurationOverrides: Optional[ConfigurationOverrides] = None
    jobDriver: Optional[JobDriver] = None
    createdAt: Optional[Date] = None
    createdBy: Optional[RequestIdentityUserArn] = None
    finishedAt: Optional[Date] = None
    stateDetails: Optional[String256] = None
    failureReason: Optional[FailureReason] = None
    tags: Optional[TagMap] = None


class Endpoint(BaseModel):
    """
    This entity represents the endpoint that is managed by Amazon EMR on EKS.
    """

    id: Optional[ResourceIdString] = None
    name: Optional[ResourceNameString] = None
    arn: Optional[EndpointArn] = None
    virtualClusterId: Optional[ResourceIdString] = None
    type: Optional[EndpointType] = None
    state: Optional[EndpointState] = None
    releaseLabel: Optional[ReleaseLabel] = None
    executionRoleArn: Optional[IAMRoleArn] = None
    certificateArn: Optional[ACMCertArn] = None
    configurationOverrides: Optional[ConfigurationOverrides] = None
    serverUrl: Optional[UriString] = None
    createdAt: Optional[Date] = None
    securityGroup: Optional[String256] = None
    subnetIds: Optional[SubnetIds] = None
    stateDetails: Optional[String256] = None
    failureReason: Optional[FailureReason] = None
    tags: Optional[TagMap] = None


class Endpoints(BaseModel):
    __root__: List[Endpoint]


class JobRuns(BaseModel):
    __root__: List[JobRun]


class StartJobRunRequest(BaseModel):
    name: Optional[ResourceNameString] = None
    clientToken: ClientToken
    executionRoleArn: IAMRoleArn
    releaseLabel: ReleaseLabel
    jobDriver: JobDriver
    configurationOverrides: Optional[ConfigurationOverrides] = None
    tags: Optional[TagMap] = None


ConfigurationList.update_forward_refs()
DescribeJobRunResponse.update_forward_refs()
DescribeManagedEndpointResponse.update_forward_refs()
ListJobRunsResponse.update_forward_refs()
ListManagedEndpointsResponse.update_forward_refs()
