# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2021-12-31T02:59:31+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Annotated, Any, List, Optional

from pydantic import BaseModel, Extra, Field


class AssociateWebACLResponse(BaseModel):
    pass


class WAFInternalErrorException(BaseModel):
    __root__: Any


class WAFInvalidParameterException(WAFInternalErrorException):
    pass


class WAFNonexistentItemException(WAFInternalErrorException):
    pass


class WAFUnavailableEntityException(WAFInternalErrorException):
    pass


class WAFInvalidOperationException(WAFInternalErrorException):
    pass


class WAFLimitsExceededException(WAFInternalErrorException):
    pass


class WAFInvalidResourceException(WAFInternalErrorException):
    pass


class WAFSubscriptionNotFoundException(WAFInternalErrorException):
    pass


class WAFExpiredManagedRuleGroupVersionException(WAFInternalErrorException):
    pass


class WAFDuplicateItemException(WAFInternalErrorException):
    pass


class WAFOptimisticLockException(WAFInternalErrorException):
    pass


class WAFTagOperationException(WAFInternalErrorException):
    pass


class WAFTagOperationInternalErrorException(WAFInternalErrorException):
    pass


class DeleteIPSetResponse(AssociateWebACLResponse):
    pass


class WAFAssociatedItemException(WAFInternalErrorException):
    pass


class DeleteLoggingConfigurationResponse(AssociateWebACLResponse):
    pass


class DeletePermissionPolicyResponse(AssociateWebACLResponse):
    pass


class DeleteRegexPatternSetResponse(AssociateWebACLResponse):
    pass


class DeleteRuleGroupResponse(AssociateWebACLResponse):
    pass


class DeleteWebACLResponse(AssociateWebACLResponse):
    pass


class DisassociateWebACLResponse(AssociateWebACLResponse):
    pass


class WAFServiceLinkedRoleErrorException(WAFInternalErrorException):
    pass


class PutPermissionPolicyResponse(AssociateWebACLResponse):
    pass


class WAFInvalidPermissionPolicyException(WAFInternalErrorException):
    pass


class TagResourceResponse(AssociateWebACLResponse):
    pass


class UntagResourceResponse(AssociateWebACLResponse):
    pass


class Action(BaseModel):
    __root__: str


class ActionValue(Enum):
    ALLOW = 'ALLOW'
    BLOCK = 'BLOCK'
    COUNT = 'COUNT'


class ActionCondition(BaseModel):
    """
    A single action condition for a <a>Condition</a> in a logging filter.
    """

    Action: ActionValue


class All(AssociateWebACLResponse):
    """
    <p>Inspect all of the elements that WAF has parsed and extracted from the web request JSON body that are within the <a>JsonBody</a> <code>MatchScope</code>. This is used with the <a>FieldToMatch</a> option <code>JsonBody</code>. </p> <p>This is used only to indicate the web request component for WAF to inspect, in the <a>FieldToMatch</a> specification. </p> <p>JSON specification: <code>"All": {}</code> </p>
    """

    pass


class AllQueryArguments(AssociateWebACLResponse):
    """
    <p>All query arguments of a web request. </p> <p>This is used only to indicate the web request component for WAF to inspect, in the <a>FieldToMatch</a> specification. </p> <p>JSON specification: <code>"AllQueryArguments": {}</code> </p>
    """

    pass


class ResourceArn(BaseModel):
    __root__: Annotated[str, Field(max_length=2048, min_length=20, regex='.*\\S.*')]


class Body(AssociateWebACLResponse):
    """
    <p>The body of a web request. This immediately follows the request headers.</p> <p>This is used only to indicate the web request component for WAF to inspect, in the <a>FieldToMatch</a> specification. </p> <p>JSON specification: <code>"Body": {}</code> </p>
    """

    pass


class BodyParsingFallbackBehavior(Enum):
    MATCH = 'MATCH'
    NO_MATCH = 'NO_MATCH'
    EVALUATE_AS_STRING = 'EVALUATE_AS_STRING'


class Boolean(BaseModel):
    __root__: bool


class SearchString(Action):
    pass


class PositionalConstraint(Enum):
    EXACTLY = 'EXACTLY'
    STARTS_WITH = 'STARTS_WITH'
    ENDS_WITH = 'ENDS_WITH'
    CONTAINS = 'CONTAINS'
    CONTAINS_WORD = 'CONTAINS_WORD'


class CapacityUnit(BaseModel):
    __root__: Annotated[int, Field(ge=1.0)]


class Scope(Enum):
    CLOUDFRONT = 'CLOUDFRONT'
    REGIONAL = 'REGIONAL'


class ConsumedCapacity(BaseModel):
    __root__: Annotated[int, Field(ge=0.0)]


class ComparisonOperator(Enum):
    EQ = 'EQ'
    NE = 'NE'
    LE = 'LE'
    LT = 'LT'
    GE = 'GE'
    GT = 'GT'


class Country(Action):
    pass


class CountryCode(Enum):
    AF = 'AF'
    AX = 'AX'
    AL = 'AL'
    DZ = 'DZ'
    AS = 'AS'
    AD = 'AD'
    AO = 'AO'
    AI = 'AI'
    AQ = 'AQ'
    AG = 'AG'
    AR = 'AR'
    AM = 'AM'
    AW = 'AW'
    AU = 'AU'
    AT = 'AT'
    AZ = 'AZ'
    BS = 'BS'
    BH = 'BH'
    BD = 'BD'
    BB = 'BB'
    BY = 'BY'
    BE = 'BE'
    BZ = 'BZ'
    BJ = 'BJ'
    BM = 'BM'
    BT = 'BT'
    BO = 'BO'
    BQ = 'BQ'
    BA = 'BA'
    BW = 'BW'
    BV = 'BV'
    BR = 'BR'
    IO = 'IO'
    BN = 'BN'
    BG = 'BG'
    BF = 'BF'
    BI = 'BI'
    KH = 'KH'
    CM = 'CM'
    CA = 'CA'
    CV = 'CV'
    KY = 'KY'
    CF = 'CF'
    TD = 'TD'
    CL = 'CL'
    CN = 'CN'
    CX = 'CX'
    CC = 'CC'
    CO = 'CO'
    KM = 'KM'
    CG = 'CG'
    CD = 'CD'
    CK = 'CK'
    CR = 'CR'
    CI = 'CI'
    HR = 'HR'
    CU = 'CU'
    CW = 'CW'
    CY = 'CY'
    CZ = 'CZ'
    DK = 'DK'
    DJ = 'DJ'
    DM = 'DM'
    DO = 'DO'
    EC = 'EC'
    EG = 'EG'
    SV = 'SV'
    GQ = 'GQ'
    ER = 'ER'
    EE = 'EE'
    ET = 'ET'
    FK = 'FK'
    FO = 'FO'
    FJ = 'FJ'
    FI = 'FI'
    FR = 'FR'
    GF = 'GF'
    PF = 'PF'
    TF = 'TF'
    GA = 'GA'
    GM = 'GM'
    GE = 'GE'
    DE = 'DE'
    GH = 'GH'
    GI = 'GI'
    GR = 'GR'
    GL = 'GL'
    GD = 'GD'
    GP = 'GP'
    GU = 'GU'
    GT = 'GT'
    GG = 'GG'
    GN = 'GN'
    GW = 'GW'
    GY = 'GY'
    HT = 'HT'
    HM = 'HM'
    VA = 'VA'
    HN = 'HN'
    HK = 'HK'
    HU = 'HU'
    IS = 'IS'
    IN = 'IN'
    ID = 'ID'
    IR = 'IR'
    IQ = 'IQ'
    IE = 'IE'
    IM = 'IM'
    IL = 'IL'
    IT = 'IT'
    JM = 'JM'
    JP = 'JP'
    JE = 'JE'
    JO = 'JO'
    KZ = 'KZ'
    KE = 'KE'
    KI = 'KI'
    KP = 'KP'
    KR = 'KR'
    KW = 'KW'
    KG = 'KG'
    LA = 'LA'
    LV = 'LV'
    LB = 'LB'
    LS = 'LS'
    LR = 'LR'
    LY = 'LY'
    LI = 'LI'
    LT = 'LT'
    LU = 'LU'
    MO = 'MO'
    MK = 'MK'
    MG = 'MG'
    MW = 'MW'
    MY = 'MY'
    MV = 'MV'
    ML = 'ML'
    MT = 'MT'
    MH = 'MH'
    MQ = 'MQ'
    MR = 'MR'
    MU = 'MU'
    YT = 'YT'
    MX = 'MX'
    FM = 'FM'
    MD = 'MD'
    MC = 'MC'
    MN = 'MN'
    ME = 'ME'
    MS = 'MS'
    MA = 'MA'
    MZ = 'MZ'
    MM = 'MM'
    NA = 'NA'
    NR = 'NR'
    NP = 'NP'
    NL = 'NL'
    NC = 'NC'
    NZ = 'NZ'
    NI = 'NI'
    NE = 'NE'
    NG = 'NG'
    NU = 'NU'
    NF = 'NF'
    MP = 'MP'
    NO = 'NO'
    OM = 'OM'
    PK = 'PK'
    PW = 'PW'
    PS = 'PS'
    PA = 'PA'
    PG = 'PG'
    PY = 'PY'
    PE = 'PE'
    PH = 'PH'
    PN = 'PN'
    PL = 'PL'
    PT = 'PT'
    PR = 'PR'
    QA = 'QA'
    RE = 'RE'
    RO = 'RO'
    RU = 'RU'
    RW = 'RW'
    BL = 'BL'
    SH = 'SH'
    KN = 'KN'
    LC = 'LC'
    MF = 'MF'
    PM = 'PM'
    VC = 'VC'
    WS = 'WS'
    SM = 'SM'
    ST = 'ST'
    SA = 'SA'
    SN = 'SN'
    RS = 'RS'
    SC = 'SC'
    SL = 'SL'
    SG = 'SG'
    SX = 'SX'
    SK = 'SK'
    SI = 'SI'
    SB = 'SB'
    SO = 'SO'
    ZA = 'ZA'
    GS = 'GS'
    SS = 'SS'
    ES = 'ES'
    LK = 'LK'
    SD = 'SD'
    SR = 'SR'
    SJ = 'SJ'
    SZ = 'SZ'
    SE = 'SE'
    CH = 'CH'
    SY = 'SY'
    TW = 'TW'
    TJ = 'TJ'
    TZ = 'TZ'
    TH = 'TH'
    TL = 'TL'
    TG = 'TG'
    TK = 'TK'
    TO = 'TO'
    TT = 'TT'
    TN = 'TN'
    TR = 'TR'
    TM = 'TM'
    TC = 'TC'
    TV = 'TV'
    UG = 'UG'
    UA = 'UA'
    AE = 'AE'
    GB = 'GB'
    US = 'US'
    UM = 'UM'
    UY = 'UY'
    UZ = 'UZ'
    VU = 'VU'
    VE = 'VE'
    VN = 'VN'
    VG = 'VG'
    VI = 'VI'
    WF = 'WF'
    EH = 'EH'
    YE = 'YE'
    ZM = 'ZM'
    ZW = 'ZW'


class CountryCodes(BaseModel):
    __root__: Annotated[List[CountryCode], Field(min_items=1)]


class EntityName(BaseModel):
    __root__: Annotated[str, Field(max_length=128, min_length=1, regex='^[\\w\\-]+$')]


class EntityDescription(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=256,
            min_length=1,
            regex='^[\\w+=:#@/\\-,\\.][\\w+=:#@/\\-,\\.\\s]+[\\w+=:#@/\\-,\\.]$',
        ),
    ]


class IPAddressVersion(Enum):
    IPV4 = 'IPV4'
    IPV6 = 'IPV6'


class CustomResponseBodies(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class CustomHTTPHeaderName(BaseModel):
    __root__: Annotated[
        str, Field(max_length=64, min_length=1, regex='^[a-zA-Z0-9._$-]+$')
    ]


class CustomHTTPHeaderValue(BaseModel):
    __root__: Annotated[str, Field(max_length=255, min_length=1, regex='.*')]


class CustomHTTPHeader(BaseModel):
    """
    A custom header for custom request and response handling. This is used in <a>CustomResponse</a> and <a>CustomRequestHandling</a>.
    """

    Name: CustomHTTPHeaderName
    Value: CustomHTTPHeaderValue


class CustomHTTPHeaders(BaseModel):
    __root__: Annotated[List[CustomHTTPHeader], Field(min_items=1)]


class ResponseStatusCode(BaseModel):
    __root__: Annotated[int, Field(ge=200.0, le=600.0)]


class ResponseContentType(Enum):
    TEXT_PLAIN = 'TEXT_PLAIN'
    TEXT_HTML = 'TEXT_HTML'
    APPLICATION_JSON = 'APPLICATION_JSON'


class ResponseContent(BaseModel):
    __root__: Annotated[str, Field(max_length=10240, min_length=1, regex='[\\s\\S]*')]


class LockToken(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=36,
            min_length=1,
            regex='^[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$',
        ),
    ]


class EntityId(LockToken):
    pass


class VendorName(BaseModel):
    __root__: Annotated[str, Field(max_length=128, min_length=1, regex='.*\\S.*')]


class VersionKeyString(BaseModel):
    __root__: Annotated[
        str, Field(max_length=64, min_length=1, regex='^[\\w#:\\.\\-/]+$')
    ]


class LabelName(BaseModel):
    __root__: Annotated[
        str, Field(max_length=1024, min_length=1, regex='^[0-9A-Za-z_\\-:]+$')
    ]


class ExcludedRule(BaseModel):
    """
    Specifies a single rule to exclude from the rule group. Excluding a rule overrides its action setting for the rule group in the web ACL, setting it to <code>COUNT</code>. This effectively excludes the rule from acting on web requests.
    """

    Name: EntityName


class ExcludedRules(BaseModel):
    __root__: List[ExcludedRule]


class FallbackBehavior(Enum):
    MATCH = 'MATCH'
    NO_MATCH = 'NO_MATCH'


class UriPath(AssociateWebACLResponse):
    """
    <p>The path component of the URI of a web request. This is the part of a web request that identifies a resource. For example, <code>/images/daily-ad.jpg</code>.</p> <p>This is used only to indicate the web request component for WAF to inspect, in the <a>FieldToMatch</a> specification. </p> <p>JSON specification: <code>"UriPath": {}</code> </p>
    """

    pass


class QueryString(AssociateWebACLResponse):
    """
    <p>The query string of a web request. This is the part of a URL that appears after a <code>?</code> character, if any.</p> <p>This is used only to indicate the web request component for WAF to inspect, in the <a>FieldToMatch</a> specification. </p> <p>JSON specification: <code>"QueryString": {}</code> </p>
    """

    pass


class Method(AssociateWebACLResponse):
    """
    <p>The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform. </p> <p>This is used only to indicate the web request component for WAF to inspect, in the <a>FieldToMatch</a> specification. </p> <p>JSON specification: <code>"Method": {}</code> </p>
    """

    pass


class FieldToMatchData(BaseModel):
    __root__: Annotated[str, Field(max_length=64, min_length=1, regex='.*\\S.*')]


class FilterBehavior(Enum):
    KEEP = 'KEEP'
    DROP = 'DROP'


class FilterRequirement(Enum):
    MEETS_ALL = 'MEETS_ALL'
    MEETS_ANY = 'MEETS_ANY'


class RulePriority(ConsumedCapacity):
    pass


class RuleGroupReferenceStatement(BaseModel):
    """
    <p>A rule statement used to run the rules that are defined in a <a>RuleGroup</a>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p> <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
    """

    ARN: ResourceArn
    ExcludedRules: Optional[ExcludedRules] = None


class ForwardedIPHeaderName(BaseModel):
    __root__: Annotated[
        str, Field(max_length=255, min_length=1, regex='^[a-zA-Z0-9-]+$')
    ]


class ForwardedIPConfig(BaseModel):
    """
    <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note> <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p> </note> <p>This configuration is used for <a>GeoMatchStatement</a> and <a>RateBasedStatement</a>. For <a>IPSetReferenceStatement</a>, use <a>IPSetForwardedIPConfig</a> instead. </p> <p>WAF only evaluates the first IP address found in the specified HTTP header. </p>
    """

    HeaderName: ForwardedIPHeaderName
    FallbackBehavior: FallbackBehavior


class ForwardedIPPosition(Enum):
    FIRST = 'FIRST'
    LAST = 'LAST'
    ANY = 'ANY'


class GeoMatchStatement(BaseModel):
    """
    A rule statement used to identify web requests based on country of origin.
    """

    CountryCodes: Optional[CountryCodes] = None
    ForwardedIPConfig: Optional[ForwardedIPConfig] = None


class PolicyString(BaseModel):
    __root__: Annotated[str, Field(max_length=395000, min_length=1, regex='.*\\S.*')]


class MetricName(BaseModel):
    __root__: Annotated[
        str, Field(max_length=255, min_length=1, regex='^[\\w#:\\.\\-/]+$')
    ]


class ListMaxItems(BaseModel):
    __root__: Annotated[int, Field(ge=1.0, le=500.0)]


class PopulationSize(BaseModel):
    __root__: int


class HeaderName1(Action):
    pass


class HeaderValue(Action):
    pass


class HTTPHeader(BaseModel):
    """
    Part of the response from <a>GetSampledRequests</a>. This is a complex type that appears as <code>Headers</code> in the response syntax. <code>HTTPHeader</code> contains the names and values of all of the headers that appear in one of the web requests.
    """

    Name: Optional[HeaderName1] = None
    Value: Optional[HeaderValue] = None


class HTTPHeaders(BaseModel):
    __root__: List[HTTPHeader]


class HTTPMethod(Action):
    pass


class IPString(Action):
    pass


class URIString(Action):
    pass


class HTTPVersion(Action):
    pass


class HTTPRequest(BaseModel):
    """
    Part of the response from <a>GetSampledRequests</a>. This is a complex type that appears as <code>Request</code> in the response syntax. <code>HTTPRequest</code> contains information about one of the web requests.
    """

    ClientIP: Optional[IPString] = None
    Country: Optional[Country] = None
    URI: Optional[URIString] = None
    Method: Optional[HTTPMethod] = None
    HTTPVersion: Optional[HTTPVersion] = None
    Headers: Optional[HTTPHeaders] = None


class IPAddress(BaseModel):
    __root__: Annotated[str, Field(max_length=50, min_length=1, regex='.*\\S.*')]


class IPSetForwardedIPConfig(BaseModel):
    """
    <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note> <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p> </note> <p>This configuration is used only for <a>IPSetReferenceStatement</a>. For <a>GeoMatchStatement</a> and <a>RateBasedStatement</a>, use <a>ForwardedIPConfig</a> instead. </p>
    """

    HeaderName: ForwardedIPHeaderName
    FallbackBehavior: FallbackBehavior
    Position: ForwardedIPPosition


class IPSetReferenceStatement(BaseModel):
    """
    <p>A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an <a>IPSet</a> that specifies the addresses you want to detect, then use the ARN of that set in this statement. To create an IP set, see <a>CreateIPSet</a>.</p> <p>Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
    """

    ARN: ResourceArn
    IPSetForwardedIPConfig: Optional[IPSetForwardedIPConfig] = None


class JsonMatchScope(Enum):
    ALL = 'ALL'
    KEY = 'KEY'
    VALUE = 'VALUE'


class JsonPointerPath(BaseModel):
    __root__: Annotated[
        str, Field(max_length=512, min_length=1, regex='([/])|([/](([^~])|(~[01]))+)')
    ]


class Label(BaseModel):
    """
    A single label container. This is used as an element of a label array in multiple contexts, for example, in <code>RuleLabels</code> inside a <a>Rule</a> and in <code>Labels</code> inside a <a>SampledHTTPRequest</a>.
    """

    Name: LabelName


class LabelMatchKey(LabelName):
    pass


class LabelMatchScope(Enum):
    LABEL = 'LABEL'
    NAMESPACE = 'NAMESPACE'


class LabelMatchStatement(BaseModel):
    """
    <p>A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. </p> <p>The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, WAF performs the search for labels that were added in the same context as the label match statement. </p>
    """

    Scope: LabelMatchScope
    Key: LabelMatchKey


class LabelSummary(BaseModel):
    """
    <p>List of labels used by one or more of the rules of a <a>RuleGroup</a>. This summary object is used for the following rule group lists: </p> <ul> <li> <p> <code>AvailableLabels</code> - Labels that rules add to matching requests. These labels are defined in the <code>RuleLabels</code> for a <a>Rule</a>. </p> </li> <li> <p> <code>ConsumedLabels</code> - Labels that rules match against. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <a>Statement</a> definition of a rule. </p> </li> </ul>
    """

    Name: Optional[LabelName] = None


class Labels(BaseModel):
    __root__: List[Label]


class NextMarker(BaseModel):
    __root__: Annotated[str, Field(max_length=256, min_length=1, regex='.*\\S.*')]


class PaginationLimit(BaseModel):
    __root__: Annotated[int, Field(ge=1.0, le=100.0)]


class ResourceType(Enum):
    APPLICATION_LOAD_BALANCER = 'APPLICATION_LOAD_BALANCER'
    API_GATEWAY = 'API_GATEWAY'
    APPSYNC = 'APPSYNC'


class ResourceArns(BaseModel):
    __root__: List[ResourceArn]


class LogDestinationConfigs(BaseModel):
    __root__: Annotated[List[ResourceArn], Field(max_items=100, min_items=1)]


class ManagedRuleGroupSummary(BaseModel):
    """
    High-level information about a managed rule group, returned by <a>ListAvailableManagedRuleGroups</a>. This provides information like the name and vendor name, that you provide when you add a <a>ManagedRuleGroupStatement</a> to a web ACL. Managed rule groups include Amazon Web Services Managed Rules rule groups, which are free of charge to WAF customers, and Amazon Web Services Marketplace managed rule groups, which you can subscribe to through Amazon Web Services Marketplace.
    """

    VendorName: Optional[VendorName] = None
    Name: Optional[EntityName] = None
    Description: Optional[EntityDescription] = None


class Timestamp(BaseModel):
    __root__: datetime


class ManagedRuleGroupVersion(BaseModel):
    """
    Describes a single version of a managed rule group.
    """

    Name: Optional[VersionKeyString] = None
    LastUpdateTimestamp: Optional[Timestamp] = None


class PublishedVersions(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class ManagedRuleSetSummary(BaseModel):
    """
    <p>High-level information for a managed rule set. </p> <note> <p>This is intended for use only by vendors of managed rule sets. Vendors are Amazon Web Services and Amazon Web Services Marketplace sellers. </p> <p>Vendors, you can use the managed rule set APIs to provide controlled rollout of your versioned managed rule group offerings for your customers. The APIs are <code>ListManagedRuleSets</code>, <code>GetManagedRuleSet</code>, <code>PutManagedRuleSetVersions</code>, and <code>UpdateManagedRuleSetVersionExpiryDate</code>.</p> </note>
    """

    Name: Optional[EntityName] = None
    Id: Optional[EntityId] = None
    Description: Optional[EntityDescription] = None
    LockToken: Optional[LockToken] = None
    ARN: Optional[ResourceArn] = None
    LabelNamespace: Optional[LabelName] = None


class TimeWindowDay(CapacityUnit):
    pass


class ManagedRuleSetVersion(BaseModel):
    """
    <p>Information for a single version of a managed rule set. </p> <note> <p>This is intended for use only by vendors of managed rule sets. Vendors are Amazon Web Services and Amazon Web Services Marketplace sellers. </p> <p>Vendors, you can use the managed rule set APIs to provide controlled rollout of your versioned managed rule group offerings for your customers. The APIs are <code>ListManagedRuleSets</code>, <code>GetManagedRuleSet</code>, <code>PutManagedRuleSetVersions</code>, and <code>UpdateManagedRuleSetVersionExpiryDate</code>.</p> </note>
    """

    AssociatedRuleGroupArn: Optional[ResourceArn] = None
    Capacity: Optional[CapacityUnit] = None
    ForecastedLifetime: Optional[TimeWindowDay] = None
    PublishTimestamp: Optional[Timestamp] = None
    LastUpdateTimestamp: Optional[Timestamp] = None
    ExpiryTimestamp: Optional[Timestamp] = None


class NoneAction(AssociateWebACLResponse):
    """
    <p>Specifies that WAF should do nothing. This is generally used to try out a rule without performing any actions. You set the <code>OverrideAction</code> on the <a>Rule</a>. </p> <p>This is used in the context of other settings, for example to specify values for <a>RuleAction</a> and web ACL <a>DefaultAction</a>. </p> <p>JSON specification: <code>"None": {}</code> </p>
    """

    pass


class VersionsToPublish(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class RateLimit(BaseModel):
    __root__: Annotated[int, Field(ge=100.0, le=2000000000.0)]


class RateBasedStatementAggregateKeyType(Enum):
    IP = 'IP'
    FORWARDED_IP = 'FORWARDED_IP'


class RegexPatternString(BaseModel):
    __root__: Annotated[str, Field(max_length=512, min_length=1, regex='.*')]


class Regex(BaseModel):
    """
    A single regular expression. This is used in a <a>RegexPatternSet</a>.
    """

    RegexString: Optional[RegexPatternString] = None


class SampleWeight(ConsumedCapacity):
    pass


class SampledHTTPRequest(BaseModel):
    """
    Represents a single sampled web request. The response from <a>GetSampledRequests</a> includes a <code>SampledHTTPRequests</code> complex type that appears as <code>SampledRequests</code> in the response syntax. <code>SampledHTTPRequests</code> contains an array of <code>SampledHTTPRequest</code> objects.
    """

    Request: HTTPRequest
    Weight: SampleWeight
    Timestamp: Optional[Timestamp] = None
    Action: Optional[Action] = None
    RuleNameWithinRuleGroup: Optional[EntityName] = None
    RequestHeadersInserted: Optional[HTTPHeaders] = None
    ResponseCodeSent: Optional[ResponseStatusCode] = None
    Labels: Optional[Labels] = None


class Size(BaseModel):
    __root__: Annotated[int, Field(ge=0.0, le=21474836480.0)]


class TagKey(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=128, min_length=1, regex='^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$'
        ),
    ]


class TagValue(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=256, min_length=0, regex='^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$'
        ),
    ]


class Tag(BaseModel):
    """
    <p>A tag associated with an Amazon Web Services resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each Amazon Web Services resource, up to 50 tags for a resource.</p> <p>You can tag the Amazon Web Services resources that you manage through WAF: web ACLs, rule groups, IP sets, and regex pattern sets. You can't manage or view tags through the WAF console. </p>
    """

    Key: TagKey
    Value: TagValue


class TagKeyList(BaseModel):
    __root__: Annotated[List[TagKey], Field(min_items=1)]


class TextTransformationPriority(ConsumedCapacity):
    pass


class TextTransformationType(Enum):
    NONE = 'NONE'
    COMPRESS_WHITE_SPACE = 'COMPRESS_WHITE_SPACE'
    HTML_ENTITY_DECODE = 'HTML_ENTITY_DECODE'
    LOWERCASE = 'LOWERCASE'
    CMD_LINE = 'CMD_LINE'
    URL_DECODE = 'URL_DECODE'
    BASE64_DECODE = 'BASE64_DECODE'
    HEX_DECODE = 'HEX_DECODE'
    MD5 = 'MD5'
    REPLACE_COMMENTS = 'REPLACE_COMMENTS'
    ESCAPE_SEQ_DECODE = 'ESCAPE_SEQ_DECODE'
    SQL_HEX_DECODE = 'SQL_HEX_DECODE'
    CSS_DECODE = 'CSS_DECODE'
    JS_DECODE = 'JS_DECODE'
    NORMALIZE_PATH = 'NORMALIZE_PATH'
    NORMALIZE_PATH_WIN = 'NORMALIZE_PATH_WIN'
    REMOVE_NULLS = 'REMOVE_NULLS'
    REPLACE_NULLS = 'REPLACE_NULLS'
    BASE64_DECODE_EXT = 'BASE64_DECODE_EXT'
    URL_DECODE_UNI = 'URL_DECODE_UNI'
    UTF8_TO_UNICODE = 'UTF8_TO_UNICODE'


class TextTransformation(BaseModel):
    """
    Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
    """

    Priority: TextTransformationPriority
    Type: TextTransformationType


class VersionToPublish(BaseModel):
    """
    <p>A version of the named managed rule group, that the rule group's vendor publishes for use by customers. </p> <note> <p>This is intended for use only by vendors of managed rule sets. Vendors are Amazon Web Services and Amazon Web Services Marketplace sellers. </p> <p>Vendors, you can use the managed rule set APIs to provide controlled rollout of your versioned managed rule group offerings for your customers. The APIs are <code>ListManagedRuleSets</code>, <code>GetManagedRuleSet</code>, <code>PutManagedRuleSetVersions</code>, and <code>UpdateManagedRuleSetVersionExpiryDate</code>.</p> </note>
    """

    AssociatedRuleGroupArn: Optional[ResourceArn] = None
    ForecastedLifetime: Optional[TimeWindowDay] = None


class AssociateWebACLRequest(BaseModel):
    WebACLArn: ResourceArn
    ResourceArn: ResourceArn


class CheckCapacityResponse(BaseModel):
    Capacity: Optional[ConsumedCapacity] = None


class DeleteFirewallManagerRuleGroupsResponse(BaseModel):
    NextWebACLLockToken: Optional[LockToken] = None


class DeleteFirewallManagerRuleGroupsRequest(BaseModel):
    WebACLArn: ResourceArn
    WebACLLockToken: LockToken


class DeleteIPSetRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    LockToken: LockToken


class DeleteLoggingConfigurationRequest(BaseModel):
    ResourceArn: ResourceArn


class DeletePermissionPolicyRequest(BaseModel):
    ResourceArn: ResourceArn


class DeleteRegexPatternSetRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    LockToken: LockToken


class DeleteRuleGroupRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    LockToken: LockToken


class DeleteWebACLRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    LockToken: LockToken


class DescribeManagedRuleGroupRequest(BaseModel):
    VendorName: VendorName
    Name: EntityName
    Scope: Scope
    VersionName: Optional[VersionKeyString] = None


class DisassociateWebACLRequest(BaseModel):
    ResourceArn: ResourceArn


class GetIPSetRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId


class GetLoggingConfigurationRequest(BaseModel):
    ResourceArn: ResourceArn


class GetManagedRuleSetRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId


class GetPermissionPolicyResponse(BaseModel):
    Policy: Optional[PolicyString] = None


class GetPermissionPolicyRequest(BaseModel):
    ResourceArn: ResourceArn


class GetRateBasedStatementManagedKeysRequest(BaseModel):
    Scope: Scope
    WebACLName: EntityName
    WebACLId: EntityId
    RuleGroupRuleName: Optional[EntityName] = None
    RuleName: EntityName


class GetRegexPatternSetRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId


class GetRuleGroupRequest(BaseModel):
    Name: Optional[EntityName] = None
    Scope: Optional[Scope] = None
    Id: Optional[EntityId] = None
    ARN: Optional[ResourceArn] = None


class GetWebACLRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId


class GetWebACLForResourceRequest(BaseModel):
    ResourceArn: ResourceArn


class ListAvailableManagedRuleGroupVersionsRequest(BaseModel):
    VendorName: VendorName
    Name: EntityName
    Scope: Scope
    NextMarker: Optional[NextMarker] = None
    Limit: Optional[PaginationLimit] = None


class ListAvailableManagedRuleGroupsRequest(BaseModel):
    Scope: Scope
    NextMarker: Optional[NextMarker] = None
    Limit: Optional[PaginationLimit] = None


class ListIPSetsRequest(BaseModel):
    Scope: Scope
    NextMarker: Optional[NextMarker] = None
    Limit: Optional[PaginationLimit] = None


class ListLoggingConfigurationsRequest(BaseModel):
    Scope: Optional[Scope] = None
    NextMarker: Optional[NextMarker] = None
    Limit: Optional[PaginationLimit] = None


class ListManagedRuleSetsRequest(BaseModel):
    Scope: Scope
    NextMarker: Optional[NextMarker] = None
    Limit: Optional[PaginationLimit] = None


class ListRegexPatternSetsRequest(BaseModel):
    Scope: Scope
    NextMarker: Optional[NextMarker] = None
    Limit: Optional[PaginationLimit] = None


class ListResourcesForWebACLResponse(BaseModel):
    ResourceArns: Optional[ResourceArns] = None


class ListResourcesForWebACLRequest(BaseModel):
    WebACLArn: ResourceArn
    ResourceType: Optional[ResourceType] = None


class ListRuleGroupsRequest(BaseModel):
    Scope: Scope
    NextMarker: Optional[NextMarker] = None
    Limit: Optional[PaginationLimit] = None


class ListTagsForResourceRequest(BaseModel):
    NextMarker: Optional[NextMarker] = None
    Limit: Optional[PaginationLimit] = None
    ResourceARN: ResourceArn


class ListWebACLsRequest(BaseModel):
    Scope: Scope
    NextMarker: Optional[NextMarker] = None
    Limit: Optional[PaginationLimit] = None


class PutManagedRuleSetVersionsResponse(BaseModel):
    NextLockToken: Optional[LockToken] = None


class PutManagedRuleSetVersionsRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    LockToken: LockToken
    RecommendedVersion: Optional[VersionKeyString] = None
    VersionsToPublish: Optional[VersionsToPublish] = None


class PutPermissionPolicyRequest(BaseModel):
    ResourceArn: ResourceArn
    Policy: PolicyString


class UntagResourceRequest(BaseModel):
    ResourceARN: ResourceArn
    TagKeys: TagKeyList


class UpdateIPSetResponse(PutManagedRuleSetVersionsResponse):
    pass


class UpdateManagedRuleSetVersionExpiryDateResponse(BaseModel):
    ExpiringVersion: Optional[VersionKeyString] = None
    ExpiryTimestamp: Optional[Timestamp] = None
    NextLockToken: Optional[LockToken] = None


class UpdateManagedRuleSetVersionExpiryDateRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    LockToken: LockToken
    VersionToExpire: VersionKeyString
    ExpiryTimestamp: Timestamp


class UpdateRegexPatternSetResponse(PutManagedRuleSetVersionsResponse):
    pass


class UpdateRuleGroupResponse(PutManagedRuleSetVersionsResponse):
    pass


class UpdateWebACLResponse(PutManagedRuleSetVersionsResponse):
    pass


class CustomRequestHandling(BaseModel):
    """
    <p>Custom request handling behavior that inserts custom headers into a web request. You can add custom request handling for the rule actions allow and count. </p> <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    """

    InsertHeaders: CustomHTTPHeaders


class AllowAction(BaseModel):
    """
    <p>Specifies that WAF should allow the request and optionally defines additional custom handling for the request.</p> <p>This is used in the context of other settings, for example to specify values for <a>RuleAction</a> and web ACL <a>DefaultAction</a>. </p>
    """

    CustomRequestHandling: Optional[CustomRequestHandling] = None


class CustomResponse(BaseModel):
    """
    <p>A custom response to send to the client. You can define a custom response for rule actions and default web ACL actions that are set to <a>BlockAction</a>. </p> <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    """

    ResponseCode: ResponseStatusCode
    CustomResponseBodyKey: Optional[EntityName] = None
    ResponseHeaders: Optional[CustomHTTPHeaders] = None


class BlockAction(BaseModel):
    """
    <p>Specifies that WAF should block the request and optionally defines additional custom handling for the response to the web request.</p> <p>This is used in the context of other settings, for example to specify values for <a>RuleAction</a> and web ACL <a>DefaultAction</a>. </p>
    """

    CustomResponse: Optional[CustomResponse] = None


class TextTransformations(BaseModel):
    __root__: Annotated[List[TextTransformation], Field(min_items=1)]


class LabelNameCondition(BaseModel):
    """
    A single label name condition for a <a>Condition</a> in a logging filter.
    """

    LabelName: LabelName


class Condition(BaseModel):
    """
    A single match condition for a <a>Filter</a>.
    """

    ActionCondition: Optional[ActionCondition] = None
    LabelNameCondition: Optional[LabelNameCondition] = None


class Conditions(BaseModel):
    __root__: Annotated[List[Condition], Field(min_items=1)]


class CountAction(AllowAction):
    """
    <p>Specifies that WAF should count the request. Optionally defines additional custom handling for the request.</p> <p>This is used in the context of other settings, for example to specify values for <a>RuleAction</a> and web ACL <a>DefaultAction</a>. </p>
    """

    pass


class IPAddresses(BaseModel):
    __root__: List[IPAddress]


class TagList(BaseModel):
    __root__: Annotated[List[Tag], Field(min_items=1)]


class IPSetSummary(BaseModel):
    """
    High-level information about an <a>IPSet</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage an <code>IPSet</code>, and the ARN, that you provide to the <a>IPSetReferenceStatement</a> to use the address set in a <a>Rule</a>.
    """

    Name: Optional[EntityName] = None
    Id: Optional[EntityId] = None
    Description: Optional[EntityDescription] = None
    LockToken: Optional[LockToken] = None
    ARN: Optional[ResourceArn] = None


class RegularExpressionList(BaseModel):
    __root__: List[Regex]


class RegexPatternSetSummary(IPSetSummary):
    """
    High-level information about a <a>RegexPatternSet</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RegexPatternSet</code>, and the ARN, that you provide to the <a>RegexPatternSetReferenceStatement</a> to use the pattern set in a <a>Rule</a>.
    """

    pass


class VisibilityConfig(BaseModel):
    """
    Defines and enables Amazon CloudWatch metrics and web request sample collection.
    """

    SampledRequestsEnabled: Boolean
    CloudWatchMetricsEnabled: Boolean
    MetricName: MetricName


class RuleGroupSummary(IPSetSummary):
    """
    High-level information about a <a>RuleGroup</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <a>RuleGroupReferenceStatement</a> to use the rule group in a <a>Rule</a>.
    """

    pass


class DefaultAction(BaseModel):
    """
    In a <a>WebACL</a>, this is the action that you want WAF to perform when a web request doesn't match any of the rules in the <code>WebACL</code>. The default action must be a terminating action, so you can't use count.
    """

    Block: Optional[BlockAction] = None
    Allow: Optional[AllowAction] = None


class WebACLSummary(IPSetSummary):
    """
    High-level information about a <a>WebACL</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>WebACL</code>, and the ARN, that you provide to operations like <a>AssociateWebACL</a>.
    """

    pass


class CustomResponseBody(BaseModel):
    """
    The response body to use in a custom response to a web request. This is referenced by key from <a>CustomResponse</a> <code>CustomResponseBodyKey</code>.
    """

    ContentType: ResponseContentType
    Content: ResponseContent


class LabelSummaries(BaseModel):
    __root__: List[LabelSummary]


class SingleHeader(BaseModel):
    """
    <p>One of the headers in a web request, identified by name, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p> <p>This is used only to indicate the web request component for WAF to inspect, in the <a>FieldToMatch</a> specification. </p> <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
    """

    Name: FieldToMatchData


class SingleQueryArgument(SingleHeader):
    """
    <p>One query argument in a web request, identified by name, for example <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p> <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
    """

    pass


class Filter(BaseModel):
    """
    A single logging filter, used in <a>LoggingFilter</a>.
    """

    Behavior: FilterBehavior
    Requirement: FilterRequirement
    Conditions: Conditions


class Filters(BaseModel):
    __root__: Annotated[List[Filter], Field(min_items=1)]


class OverrideAction(BaseModel):
    """
    <p>The override action to apply to the rules in a rule group. Used only for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <p>Set the override action to none to leave the rule actions in effect. Set it to count to only count matches, regardless of the rule action settings. </p> <p>In a <a>Rule</a>, you must specify either this <code>OverrideAction</code> setting or the rule <code>Action</code> setting, but not both:</p> <ul> <li> <p>If the rule statement references a rule group, use this override action setting and not the action setting. </p> </li> <li> <p>If the rule statement does not reference a rule group, use the rule action setting and not this rule override action setting. </p> </li> </ul>
    """

    Count: Optional[CountAction] = None
    None_: Annotated[Optional[NoneAction], Field(alias='None')] = None


class IPSet(BaseModel):
    """
    <p>Contains one or more IP addresses or blocks of IP addresses specified in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. For information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>WAF assigns an ARN to each <code>IPSet</code> that you create. To use an IP set in a rule, you provide the ARN to the <a>Rule</a> statement <a>IPSetReferenceStatement</a>. </p>
    """

    Name: EntityName
    Id: EntityId
    ARN: ResourceArn
    Description: Optional[EntityDescription] = None
    IPAddressVersion: IPAddressVersion
    Addresses: IPAddresses


class ManagedRuleSet(BaseModel):
    """
    <p>A set of rules that is managed by Amazon Web Services and Amazon Web Services Marketplace sellers to provide versioned managed rule groups for customers of WAF.</p> <note> <p>This is intended for use only by vendors of managed rule sets. Vendors are Amazon Web Services and Amazon Web Services Marketplace sellers. </p> <p>Vendors, you can use the managed rule set APIs to provide controlled rollout of your versioned managed rule group offerings for your customers. The APIs are <code>ListManagedRuleSets</code>, <code>GetManagedRuleSet</code>, <code>PutManagedRuleSetVersions</code>, and <code>UpdateManagedRuleSetVersionExpiryDate</code>.</p> </note>
    """

    Name: EntityName
    Id: EntityId
    ARN: ResourceArn
    Description: Optional[EntityDescription] = None
    PublishedVersions: Optional[PublishedVersions] = None
    RecommendedVersion: Optional[VersionKeyString] = None
    LabelNamespace: Optional[LabelName] = None


class RateBasedStatementManagedKeysIPSet(BaseModel):
    """
    The set of IP addresses that are currently blocked for a <a>RateBasedStatement</a>.
    """

    IPAddressVersion: Optional[IPAddressVersion] = None
    Addresses: Optional[IPAddresses] = None


class RegexPatternSet(BaseModel):
    """
    <p>Contains one or more regular expressions. </p> <p>WAF assigns an ARN to each <code>RegexPatternSet</code> that you create. To use a set in a rule, you provide the ARN to the <a>Rule</a> statement <a>RegexPatternSetReferenceStatement</a>. </p>
    """

    Name: Optional[EntityName] = None
    Id: Optional[EntityId] = None
    ARN: Optional[ResourceArn] = None
    Description: Optional[EntityDescription] = None
    RegularExpressionList: Optional[RegularExpressionList] = None


class TimeWindow(BaseModel):
    """
    <p>In a <a>GetSampledRequests</a> request, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range for which you want WAF to return a sample of web requests.</p> <p>You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p> <p>In a <a>GetSampledRequests</a> response, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range for which WAF actually returned a sample of web requests. WAF gets the specified number of requests from among the first 5,000 requests that your Amazon Web Services resource receives during the specified time period. If your resource receives more than 5,000 requests during that period, WAF stops sampling after the 5,000th request. In that case, <code>EndTime</code> is the time that WAF received the 5,000th request.</p>
    """

    StartTime: Timestamp
    EndTime: Timestamp


class SampledHTTPRequests(BaseModel):
    __root__: List[SampledHTTPRequest]


class IPSetSummaries(BaseModel):
    __root__: List[IPSetSummary]


class JsonPointerPaths(BaseModel):
    __root__: Annotated[List[JsonPointerPath], Field(min_items=1)]


class ManagedRuleGroupVersions(BaseModel):
    __root__: List[ManagedRuleGroupVersion]


class ManagedRuleGroupSummaries(BaseModel):
    __root__: List[ManagedRuleGroupSummary]


class ManagedRuleSetSummaries(BaseModel):
    __root__: List[ManagedRuleSetSummary]


class RegexPatternSetSummaries(BaseModel):
    __root__: List[RegexPatternSetSummary]


class RuleGroupSummaries(BaseModel):
    __root__: List[RuleGroupSummary]


class TagInfoForResource(BaseModel):
    """
    <p>The collection of tagging definitions for an Amazon Web Services resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each Amazon Web Services resource, up to 50 tags for a resource.</p> <p>You can tag the Amazon Web Services resources that you manage through WAF: web ACLs, rule groups, IP sets, and regex pattern sets. You can't manage or view tags through the WAF console. </p>
    """

    ResourceARN: Optional[ResourceArn] = None
    TagList: Optional[TagList] = None


class WebACLSummaries(BaseModel):
    __root__: List[WebACLSummary]


class LoggingFilter(BaseModel):
    """
    <p>Filtering that specifies which web requests are kept in the logs and which are dropped, defined for a web ACL's <a>LoggingConfiguration</a>. </p> <p>You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
    """

    Filters: Filters
    DefaultBehavior: FilterBehavior


class RuleAction(BaseModel):
    """
    The action that WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting.
    """

    Block: Optional[BlockAction] = None
    Allow: Optional[AllowAction] = None
    Count: Optional[CountAction] = None


class RuleSummary(BaseModel):
    """
    High-level information about a <a>Rule</a>, returned by operations like <a>DescribeManagedRuleGroup</a>. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <a>RuleGroupReferenceStatement</a> to use the rule group in a <a>Rule</a>.
    """

    Name: Optional[EntityName] = None
    Action: Optional[RuleAction] = None


class CreateIPSetResponse(BaseModel):
    Summary: Optional[IPSetSummary] = None


class CreateIPSetRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Description: Optional[EntityDescription] = None
    IPAddressVersion: IPAddressVersion
    Addresses: IPAddresses
    Tags: Optional[TagList] = None


class CreateRegexPatternSetResponse(BaseModel):
    Summary: Optional[RegexPatternSetSummary] = None


class CreateRegexPatternSetRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Description: Optional[EntityDescription] = None
    RegularExpressionList: RegularExpressionList
    Tags: Optional[TagList] = None


class CreateRuleGroupResponse(BaseModel):
    Summary: Optional[RuleGroupSummary] = None


class CreateWebACLResponse(BaseModel):
    Summary: Optional[WebACLSummary] = None


class GetIPSetResponse(BaseModel):
    IPSet: Optional[IPSet] = None
    LockToken: Optional[LockToken] = None


class GetManagedRuleSetResponse(BaseModel):
    ManagedRuleSet: Optional[ManagedRuleSet] = None
    LockToken: Optional[LockToken] = None


class GetRateBasedStatementManagedKeysResponse(BaseModel):
    ManagedKeysIPV4: Optional[RateBasedStatementManagedKeysIPSet] = None
    ManagedKeysIPV6: Optional[RateBasedStatementManagedKeysIPSet] = None


class GetRegexPatternSetResponse(BaseModel):
    RegexPatternSet: Optional[RegexPatternSet] = None
    LockToken: Optional[LockToken] = None


class GetSampledRequestsResponse(BaseModel):
    SampledRequests: Optional[SampledHTTPRequests] = None
    PopulationSize: Optional[PopulationSize] = None
    TimeWindow: Optional[TimeWindow] = None


class GetSampledRequestsRequest(BaseModel):
    WebAclArn: ResourceArn
    RuleMetricName: MetricName
    Scope: Scope
    TimeWindow: TimeWindow
    MaxItems: ListMaxItems


class ListAvailableManagedRuleGroupVersionsResponse(BaseModel):
    NextMarker: Optional[NextMarker] = None
    Versions: Optional[ManagedRuleGroupVersions] = None


class ListAvailableManagedRuleGroupsResponse(BaseModel):
    NextMarker: Optional[NextMarker] = None
    ManagedRuleGroups: Optional[ManagedRuleGroupSummaries] = None


class ListIPSetsResponse(BaseModel):
    NextMarker: Optional[NextMarker] = None
    IPSets: Optional[IPSetSummaries] = None


class ListManagedRuleSetsResponse(BaseModel):
    NextMarker: Optional[NextMarker] = None
    ManagedRuleSets: Optional[ManagedRuleSetSummaries] = None


class ListRegexPatternSetsResponse(BaseModel):
    NextMarker: Optional[NextMarker] = None
    RegexPatternSets: Optional[RegexPatternSetSummaries] = None


class ListRuleGroupsResponse(BaseModel):
    NextMarker: Optional[NextMarker] = None
    RuleGroups: Optional[RuleGroupSummaries] = None


class ListTagsForResourceResponse(BaseModel):
    NextMarker: Optional[NextMarker] = None
    TagInfoForResource: Optional[TagInfoForResource] = None


class ListWebACLsResponse(BaseModel):
    NextMarker: Optional[NextMarker] = None
    WebACLs: Optional[WebACLSummaries] = None


class TagResourceRequest(BaseModel):
    ResourceARN: ResourceArn
    Tags: TagList


class UpdateIPSetRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    Description: Optional[EntityDescription] = None
    Addresses: IPAddresses
    LockToken: LockToken


class UpdateRegexPatternSetRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    Description: Optional[EntityDescription] = None
    RegularExpressionList: RegularExpressionList
    LockToken: LockToken


class RuleSummaries(BaseModel):
    __root__: List[RuleSummary]


class JsonMatchPattern(BaseModel):
    """
    The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. This is used with the <a>FieldToMatch</a> option <code>JsonBody</code>.
    """

    All: Optional[All] = None
    IncludedPaths: Optional[JsonPointerPaths] = None


class DescribeManagedRuleGroupResponse(BaseModel):
    VersionName: Optional[VersionKeyString] = None
    SnsTopicArn: Optional[ResourceArn] = None
    Capacity: Optional[CapacityUnit] = None
    Rules: Optional[RuleSummaries] = None
    LabelNamespace: Optional[LabelName] = None
    AvailableLabels: Optional[LabelSummaries] = None
    ConsumedLabels: Optional[LabelSummaries] = None


class JsonBody(BaseModel):
    """
    <p>The body of a web request, inspected as JSON. The body immediately follows the request headers. This is used in the <a>FieldToMatch</a> specification.</p> <p>Use the specifications in this object to indicate which parts of the JSON body to inspect using the rule's inspection criteria. WAF inspects only the parts of the JSON that result from the matches that you indicate. </p> <p>Example JSON: <code>"JsonBody": { "MatchPattern": { "All": {} }, "MatchScope": "ALL" }</code> </p>
    """

    MatchPattern: JsonMatchPattern
    MatchScope: JsonMatchScope
    InvalidFallbackBehavior: Optional[BodyParsingFallbackBehavior] = None


class FieldToMatch(BaseModel):
    """
    <p>The part of a web request that you want WAF to inspect. Include the single <code>FieldToMatch</code> type that you want to inspect, with additional specifications as needed, according to the type. You specify a single request component in <code>FieldToMatch</code> for each rule statement that requires it. To inspect more than one component of a web request, create a separate rule statement for each component.</p> <p>JSON specification for a <code>QueryString</code> field to match: </p> <p> <code> "FieldToMatch": { "QueryString": {} }</code> </p> <p>Example JSON for a <code>Method</code> field to match specification:</p> <p> <code> "FieldToMatch": { "Method": { "Name": "DELETE" } }</code> </p>
    """

    SingleHeader: Optional[SingleHeader] = None
    SingleQueryArgument: Optional[SingleQueryArgument] = None
    AllQueryArguments: Optional[AllQueryArguments] = None
    UriPath: Optional[UriPath] = None
    QueryString: Optional[QueryString] = None
    Body: Optional[Body] = None
    Method: Optional[Method] = None
    JsonBody: Optional[JsonBody] = None


class ByteMatchStatement(BaseModel):
    """
    A rule statement that defines a string match search for WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the WAF console and the developer guide, this is refered to as a string match statement.
    """

    SearchString: SearchString
    FieldToMatch: FieldToMatch
    TextTransformations: TextTransformations
    PositionalConstraint: PositionalConstraint


class RedactedFields(BaseModel):
    __root__: Annotated[List[FieldToMatch], Field(max_items=100)]


class RegexPatternSetReferenceStatement(BaseModel):
    """
    <p>A rule statement used to search web request components for matches with regular expressions. To use this, create a <a>RegexPatternSet</a> that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set. To create a regex pattern set, see <a>CreateRegexPatternSet</a>.</p> <p>Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
    """

    ARN: ResourceArn
    FieldToMatch: FieldToMatch
    TextTransformations: TextTransformations


class SizeConstraintStatement(BaseModel):
    """
    <p>A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (&gt;) or less than (&lt;). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes. </p> <p>If you configure WAF to inspect the request body, WAF inspects only the first 8192 bytes (8 KB). If the request body for your web requests never exceeds 8192 bytes, you can create a size constraint condition and block requests that have a request body greater than 8192 bytes.</p> <p>If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
    """

    FieldToMatch: FieldToMatch
    ComparisonOperator: ComparisonOperator
    Size: Size
    TextTransformations: TextTransformations


class SqliMatchStatement(BaseModel):
    """
    Attackers sometimes insert malicious SQL code into web requests in an effort to extract data from your database. To allow or block web requests that appear to contain malicious SQL code, create one or more SQL injection match conditions. An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want WAF to inspect. Later in the process, when you create a web ACL, you specify whether to allow or block requests that appear to contain malicious SQL code.
    """

    FieldToMatch: FieldToMatch
    TextTransformations: TextTransformations


class XssMatchStatement(SqliMatchStatement):
    """
    A rule statement that defines a cross-site scripting (XSS) match search for WAF to apply to web requests. XSS attacks are those where the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers. The XSS match statement provides the location in requests that you want WAF to search and text transformations to use on the search area before WAF searches for character sequences that are likely to be malicious strings.
    """

    pass


class LoggingConfiguration(BaseModel):
    """
    Defines an association between Amazon Kinesis Data Firehose destinations and a web ACL resource, for logging from WAF. As part of the association, you can specify parts of the standard logging fields to keep out of the logs and you can specify filters so that you log only a subset of the logging records.
    """

    ResourceArn: ResourceArn
    LogDestinationConfigs: LogDestinationConfigs
    RedactedFields: Optional[RedactedFields] = None
    ManagedByFirewallManager: Optional[Boolean] = None
    LoggingFilter: Optional[LoggingFilter] = None


class LoggingConfigurations(BaseModel):
    __root__: List[LoggingConfiguration]


class GetLoggingConfigurationResponse(BaseModel):
    LoggingConfiguration: Optional[LoggingConfiguration] = None


class ListLoggingConfigurationsResponse(BaseModel):
    LoggingConfigurations: Optional[LoggingConfigurations] = None
    NextMarker: Optional[NextMarker] = None


class PutLoggingConfigurationResponse(GetLoggingConfigurationResponse):
    pass


class PutLoggingConfigurationRequest(BaseModel):
    LoggingConfiguration: LoggingConfiguration


class CheckCapacityRequest(BaseModel):
    Scope: Scope
    Rules: Rules


class CreateRuleGroupRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Capacity: CapacityUnit
    Description: Optional[EntityDescription] = None
    Rules: Optional[Rules] = None
    VisibilityConfig: VisibilityConfig
    Tags: Optional[TagList] = None
    CustomResponseBodies: Optional[CustomResponseBodies] = None


class CreateWebACLRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    DefaultAction: DefaultAction
    Description: Optional[EntityDescription] = None
    Rules: Optional[Rules] = None
    VisibilityConfig: VisibilityConfig
    Tags: Optional[TagList] = None
    CustomResponseBodies: Optional[CustomResponseBodies] = None


class GetRuleGroupResponse(BaseModel):
    RuleGroup: Optional[RuleGroup] = None
    LockToken: Optional[LockToken] = None


class GetWebACLResponse(BaseModel):
    WebACL: Optional[WebACL] = None
    LockToken: Optional[LockToken] = None


class GetWebACLForResourceResponse(BaseModel):
    WebACL: Optional[WebACL] = None


class UpdateRuleGroupRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    Description: Optional[EntityDescription] = None
    Rules: Optional[Rules] = None
    VisibilityConfig: VisibilityConfig
    LockToken: LockToken
    CustomResponseBodies: Optional[CustomResponseBodies] = None


class UpdateWebACLRequest(BaseModel):
    Name: EntityName
    Scope: Scope
    Id: EntityId
    DefaultAction: DefaultAction
    Description: Optional[EntityDescription] = None
    Rules: Optional[Rules] = None
    VisibilityConfig: VisibilityConfig
    LockToken: LockToken
    CustomResponseBodies: Optional[CustomResponseBodies] = None


class Statements(BaseModel):
    __root__: List[Statement]


class AndStatement(BaseModel):
    """
    A logical rule statement used to combine other rule statements with AND logic. You provide more than one <a>Statement</a> within the <code>AndStatement</code>.
    """

    Statements: Statements


class Rules(BaseModel):
    __root__: List[Rule]


class FirewallManagerStatement(BaseModel):
    """
    The processing guidance for an Firewall Manager rule. This is like a regular rule <a>Statement</a>, but it can only contain a rule group reference.
    """

    ManagedRuleGroupStatement: Optional[ManagedRuleGroupStatement] = None
    RuleGroupReferenceStatement: Optional[RuleGroupReferenceStatement] = None


class FirewallManagerRuleGroup(BaseModel):
    """
    A rule group that's defined for an Firewall Manager WAF policy.
    """

    Name: EntityName
    Priority: RulePriority
    FirewallManagerStatement: FirewallManagerStatement
    OverrideAction: OverrideAction
    VisibilityConfig: VisibilityConfig


class FirewallManagerRuleGroups(BaseModel):
    __root__: List[FirewallManagerRuleGroup]


class ManagedRuleGroupStatement(BaseModel):
    """
    <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <a>ListAvailableManagedRuleGroups</a>.</p> <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    """

    VendorName: VendorName
    Name: EntityName
    Version: Optional[VersionKeyString] = None
    ExcludedRules: Optional[ExcludedRules] = None
    ScopeDownStatement: Optional[Statement] = None


class RuleGroup(BaseModel):
    """
    A rule group defines a collection of rules to inspect and control web requests that you can use in a <a>WebACL</a>. When you create a rule group, you define an immutable capacity limit. If you update a rule group, you must stay within the capacity. This allows others to reuse the rule group with confidence in its capacity requirements.
    """

    Name: EntityName
    Id: EntityId
    Capacity: CapacityUnit
    ARN: ResourceArn
    Description: Optional[EntityDescription] = None
    Rules: Optional[Rules] = None
    VisibilityConfig: VisibilityConfig
    LabelNamespace: Optional[LabelName] = None
    CustomResponseBodies: Optional[CustomResponseBodies] = None
    AvailableLabels: Optional[LabelSummaries] = None
    ConsumedLabels: Optional[LabelSummaries] = None


class WebACL(BaseModel):
    """
    A web ACL defines a collection of rules to use to inspect and control web requests. Each rule has an action defined (allow, block, or count) for requests that match the statement of the rule. In the web ACL, you assign a default action to take (allow, block) for any request that does not match any of the rules. The rules in a web ACL can be a combination of the types <a>Rule</a>, <a>RuleGroup</a>, and managed rule group. You can associate a web ACL with one or more Amazon Web Services resources to protect. The resources can be an Amazon CloudFront distribution, an Amazon API Gateway REST API, an Application Load Balancer, or an AppSync GraphQL API.
    """

    Name: EntityName
    Id: EntityId
    ARN: ResourceArn
    DefaultAction: DefaultAction
    Description: Optional[EntityDescription] = None
    Rules: Optional[Rules] = None
    VisibilityConfig: VisibilityConfig
    Capacity: Optional[ConsumedCapacity] = None
    PreProcessFirewallManagerRuleGroups: Optional[FirewallManagerRuleGroups] = None
    PostProcessFirewallManagerRuleGroups: Optional[FirewallManagerRuleGroups] = None
    ManagedByFirewallManager: Optional[Boolean] = None
    LabelNamespace: Optional[LabelName] = None
    CustomResponseBodies: Optional[CustomResponseBodies] = None


class Statement(BaseModel):
    """
    The processing guidance for a <a>Rule</a>, used by WAF to determine whether a web request matches the rule.
    """

    ByteMatchStatement: Optional[ByteMatchStatement] = None
    SqliMatchStatement: Optional[SqliMatchStatement] = None
    XssMatchStatement: Optional[XssMatchStatement] = None
    SizeConstraintStatement: Optional[SizeConstraintStatement] = None
    GeoMatchStatement: Optional[GeoMatchStatement] = None
    RuleGroupReferenceStatement: Optional[RuleGroupReferenceStatement] = None
    IPSetReferenceStatement: Optional[IPSetReferenceStatement] = None
    RegexPatternSetReferenceStatement: Optional[
        RegexPatternSetReferenceStatement
    ] = None
    RateBasedStatement: Optional[RateBasedStatement] = None
    AndStatement: Optional[AndStatement] = None
    OrStatement: Optional[OrStatement] = None
    NotStatement: Optional[NotStatement] = None
    ManagedRuleGroupStatement: Optional[ManagedRuleGroupStatement] = None
    LabelMatchStatement: Optional[LabelMatchStatement] = None


class NotStatement(BaseModel):
    """
    A logical rule statement used to negate the results of another rule statement. You provide one <a>Statement</a> within the <code>NotStatement</code>.
    """

    Statement: Statement


class OrStatement(AndStatement):
    """
    A logical rule statement used to combine other rule statements with OR logic. You provide more than one <a>Statement</a> within the <code>OrStatement</code>.
    """

    pass


class RateBasedStatement(BaseModel):
    """
    <p>A rate-based rule tracks the rate of requests for each originating IP address, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any 5-minute time span. You can use this to put a temporary block on requests from an IP address that is sending excessive requests. </p> <p>WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by WAF. If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by WAF. </p> <p>When the rule action triggers, WAF blocks additional requests from the IP address until the request rate falls below the limit.</p> <p>You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts requests that match the nested statement. For example, based on recent requests that you have seen from an attacker, you might create a rate-based rule with a nested AND rule statement that contains the following nested statements:</p> <ul> <li> <p>An IP match statement with an IP set that specified the address 192.0.2.44.</p> </li> <li> <p>A string match statement that searches in the User-Agent header for the string BadBot.</p> </li> </ul> <p>In this rate-based rule, you also define a rate limit. For this example, the rate limit is 1,000. Requests that meet both of the conditions in the statements are counted. If the count exceeds 1,000 requests per five minutes, the rule action triggers. Requests that do not meet both conditions are not counted towards the rate limit and are not affected by this rule.</p> <p>You cannot nest a <code>RateBasedStatement</code> inside another statement, for example inside a <code>NotStatement</code> or <code>OrStatement</code>. You can define a <code>RateBasedStatement</code> inside a web ACL and inside a rule group. </p>
    """

    Limit: RateLimit
    AggregateKeyType: RateBasedStatementAggregateKeyType
    ScopeDownStatement: Optional[Statement] = None
    ForwardedIPConfig: Optional[ForwardedIPConfig] = None


class Rule(BaseModel):
    """
    A single rule, which you can use in a <a>WebACL</a> or <a>RuleGroup</a> to identify web requests that you want to allow, block, or count. Each rule includes one top-level <a>Statement</a> that WAF uses to identify matching web requests, and parameters that govern how WAF handles them.
    """

    Name: EntityName
    Priority: RulePriority
    Statement: Statement
    Action: Optional[RuleAction] = None
    OverrideAction: Optional[OverrideAction] = None
    RuleLabels: Optional[Labels] = None
    VisibilityConfig: VisibilityConfig


CheckCapacityRequest.update_forward_refs()
CreateRuleGroupRequest.update_forward_refs()
CreateWebACLRequest.update_forward_refs()
GetRuleGroupResponse.update_forward_refs()
GetWebACLResponse.update_forward_refs()
GetWebACLForResourceResponse.update_forward_refs()
UpdateRuleGroupRequest.update_forward_refs()
UpdateWebACLRequest.update_forward_refs()
Statements.update_forward_refs()
Rules.update_forward_refs()
FirewallManagerStatement.update_forward_refs()
ManagedRuleGroupStatement.update_forward_refs()
Statement.update_forward_refs()
