# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2021-12-31T02:51:54+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, List, Optional

from pydantic import BaseModel, Extra, Field


class InvalidParameterException(BaseModel):
    __root__: Any


class ResourceNotFoundException(InvalidParameterException):
    pass


class OperationAbortedException(InvalidParameterException):
    pass


class ServiceUnavailableException(InvalidParameterException):
    pass


class InvalidOperationException(InvalidParameterException):
    pass


class LimitExceededException(InvalidParameterException):
    pass


class ResourceAlreadyExistsException(InvalidParameterException):
    pass


class InvalidSequenceTokenException(InvalidParameterException):
    pass


class DataAlreadyAcceptedException(InvalidParameterException):
    pass


class UnrecognizedClientException(InvalidParameterException):
    pass


class MalformedQueryException(InvalidParameterException):
    pass


class AccessPolicy(BaseModel):
    __root__: Annotated[str, Field(min_length=1)]


class Arn(BaseModel):
    __root__: str


class LogGroupName(BaseModel):
    __root__: Annotated[
        str, Field(max_length=512, min_length=1, regex='[\\.\\-_/#A-Za-z0-9]+')
    ]


class KmsKeyId(BaseModel):
    __root__: Annotated[str, Field(max_length=256)]


class ExportTaskId(BaseModel):
    __root__: Annotated[str, Field(max_length=512, min_length=1)]


class ExportTaskName(ExportTaskId):
    pass


class LogStreamName(BaseModel):
    __root__: Annotated[str, Field(max_length=512, min_length=1, regex='[^:*]*')]


class Timestamp(BaseModel):
    __root__: Annotated[int, Field(ge=0.0)]


class ExportDestinationBucket(ExportTaskId):
    pass


class ExportDestinationPrefix(Arn):
    pass


class Tags(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class Days(BaseModel):
    __root__: Annotated[
        int,
        Field(
            description='<p>The number of days to retain the log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.</p> <p>To set a log group to never have log events expire, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>. </p>'
        ),
    ]


class DefaultValue(BaseModel):
    __root__: float


class DestinationName(LogStreamName):
    pass


class FilterName(LogStreamName):
    pass


class QueryId(BaseModel):
    __root__: Annotated[str, Field(max_length=256, min_length=0)]


class Success(BaseModel):
    __root__: bool


class PolicyName(Arn):
    pass


class Descending(Success):
    pass


class NextToken(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description='The token for the next set of items to return. The token expires after 24 hours.',
            min_length=1,
        ),
    ]


class DescribeLimit(BaseModel):
    __root__: Annotated[int, Field(ge=1.0, le=50.0)]


class ExportTaskStatusCode(Enum):
    CANCELLED = 'CANCELLED'
    COMPLETED = 'COMPLETED'
    FAILED = 'FAILED'
    PENDING = 'PENDING'
    PENDING_CANCEL = 'PENDING_CANCEL'
    RUNNING = 'RUNNING'


class OrderBy(Enum):
    LogStreamName = 'LogStreamName'
    LastEventTime = 'LastEventTime'


class MetricName(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description='The name of the CloudWatch metric to which the monitored log information should be published. For example, you might publish to a metric named ErrorCount.',
            max_length=255,
            regex='[^:*$]*',
        ),
    ]


class MetricNamespace(BaseModel):
    __root__: Annotated[str, Field(max_length=255, regex='[^:*$]*')]


class DescribeQueriesMaxResults(BaseModel):
    __root__: Annotated[int, Field(ge=1.0, le=1000.0)]


class QueryStatus(Enum):
    Scheduled = 'Scheduled'
    Running = 'Running'
    Complete = 'Complete'
    Failed = 'Failed'
    Cancelled = 'Cancelled'
    Timeout = 'Timeout'
    Unknown = 'Unknown'


class QueryDefinitionName(BaseModel):
    __root__: Annotated[
        str, Field(max_length=255, min_length=1, regex='^([^:*\\/]+\\/?)*[^:*\\/]+$')
    ]


class QueryListMaxResults(DescribeQueriesMaxResults):
    pass


class TargetArn(AccessPolicy):
    pass


class RoleArn(AccessPolicy):
    pass


class Destination(BaseModel):
    """
    Represents a cross-account destination that receives subscription log events.
    """

    destinationName: Optional[DestinationName] = None
    targetArn: Optional[TargetArn] = None
    roleArn: Optional[RoleArn] = None
    accessPolicy: Optional[AccessPolicy] = None
    arn: Optional[Arn] = None
    creationTime: Optional[Timestamp] = None


class DestinationArn(AccessPolicy):
    pass


class DimensionsValue(BaseModel):
    __root__: Annotated[str, Field(max_length=255)]


class Dimensions(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class DimensionsKey(DimensionsValue):
    pass


class Distribution(Enum):
    """
    The method used to distribute log data to the destination, which can be either random or grouped by log stream.
    """

    Random = 'Random'
    ByLogStream = 'ByLogStream'


class EventId(Arn):
    pass


class EventMessage(AccessPolicy):
    pass


class EventNumber(BaseModel):
    __root__: int


class EventsLimit(BaseModel):
    __root__: Annotated[int, Field(ge=1.0, le=10000.0)]


class ExportTaskExecutionInfo(BaseModel):
    """
    Represents the status of an export task.
    """

    creationTime: Optional[Timestamp] = None
    completionTime: Optional[Timestamp] = None


class ExportTaskStatusMessage(Arn):
    pass


class Value(Arn):
    pass


class ExtractedValues(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class FieldModel(Arn):
    pass


class FilterCount(EventNumber):
    pass


class InputLogStreamNames(BaseModel):
    __root__: Annotated[List[LogStreamName], Field(max_items=100, min_items=1)]


class FilterPattern(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description='A symbolic description of how CloudWatch Logs should interpret the data in each log event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You use the filter pattern to specify what to look for in the log event message.',
            max_length=1024,
            min_length=0,
        ),
    ]


class Interleaved(Success):
    pass


class FilteredLogEvent(BaseModel):
    """
    Represents a matched event.
    """

    logStreamName: Optional[LogStreamName] = None
    timestamp: Optional[Timestamp] = None
    message: Optional[EventMessage] = None
    ingestionTime: Optional[Timestamp] = None
    eventId: Optional[EventId] = None


class StartFromHead(Success):
    pass


class LogRecordPointer(Arn):
    pass


class LogRecord(ExtractedValues):
    pass


class InputLogEvent(BaseModel):
    """
    Represents a log event, which is a record of activity that was recorded by the application or resource being monitored.
    """

    timestamp: Timestamp
    message: EventMessage


class InputLogEvents(BaseModel):
    __root__: Annotated[List[InputLogEvent], Field(max_items=10000, min_items=1)]


class LogEventIndex(EventNumber):
    pass


class StoredBytes(Timestamp):
    pass


class LogGroup(BaseModel):
    """
    Represents a log group.
    """

    logGroupName: Optional[LogGroupName] = None
    creationTime: Optional[Timestamp] = None
    retentionInDays: Optional[Days] = None
    metricFilterCount: Optional[FilterCount] = None
    arn: Optional[Arn] = None
    storedBytes: Optional[StoredBytes] = None
    kmsKeyId: Optional[KmsKeyId] = None


class Percentage(BaseModel):
    __root__: Annotated[int, Field(ge=0.0, le=100.0)]


class LogGroupField(BaseModel):
    """
    The fields contained in log events found by a <code>GetLogGroupFields</code> operation, along with the percentage of queried log events in which each field appears.
    """

    name: Optional[FieldModel] = None
    percent: Optional[Percentage] = None


class LogGroupNames(BaseModel):
    __root__: List[LogGroupName]


class SequenceToken(AccessPolicy):
    pass


class LogStream(BaseModel):
    """
    Represents a log stream, which is a sequence of log events from a single emitter of logs.
    """

    logStreamName: Optional[LogStreamName] = None
    creationTime: Optional[Timestamp] = None
    firstEventTimestamp: Optional[Timestamp] = None
    lastEventTimestamp: Optional[Timestamp] = None
    lastIngestionTime: Optional[Timestamp] = None
    uploadSequenceToken: Optional[SequenceToken] = None
    arn: Optional[Arn] = None
    storedBytes: Optional[StoredBytes] = None


class LogStreamSearchedCompletely(Success):
    pass


class MetricFilterMatchRecord(BaseModel):
    """
    Represents a matched event.
    """

    eventNumber: Optional[EventNumber] = None
    eventMessage: Optional[EventMessage] = None
    extractedValues: Optional[ExtractedValues] = None


class MetricFilterMatches(BaseModel):
    __root__: List[MetricFilterMatchRecord]


class MetricValue(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description='The value to publish to the CloudWatch metric. For example, if you\'re counting the occurrences of a term like "Error", the value is "1" for each occurrence. If you\'re counting the bytes transferred, the value is the value in the log event.',
            max_length=100,
        ),
    ]


class StandardUnit(Enum):
    Seconds = 'Seconds'
    Microseconds = 'Microseconds'
    Milliseconds = 'Milliseconds'
    Bytes = 'Bytes'
    Kilobytes = 'Kilobytes'
    Megabytes = 'Megabytes'
    Gigabytes = 'Gigabytes'
    Terabytes = 'Terabytes'
    Bits = 'Bits'
    Kilobits = 'Kilobits'
    Megabits = 'Megabits'
    Gigabits = 'Gigabits'
    Terabits = 'Terabits'
    Percent = 'Percent'
    Count = 'Count'
    Bytes_Second = 'Bytes/Second'
    Kilobytes_Second = 'Kilobytes/Second'
    Megabytes_Second = 'Megabytes/Second'
    Gigabytes_Second = 'Gigabytes/Second'
    Terabytes_Second = 'Terabytes/Second'
    Bits_Second = 'Bits/Second'
    Kilobits_Second = 'Kilobits/Second'
    Megabits_Second = 'Megabits/Second'
    Gigabits_Second = 'Gigabits/Second'
    Terabits_Second = 'Terabits/Second'
    Count_Second = 'Count/Second'
    None_ = 'None'


class MetricTransformation(BaseModel):
    """
    Indicates how to transform ingested log events to metric data in a CloudWatch metric.
    """

    metricName: MetricName
    metricNamespace: MetricNamespace
    metricValue: MetricValue
    defaultValue: Optional[DefaultValue] = None
    dimensions: Optional[Dimensions] = None
    unit: Optional[StandardUnit] = None


class OutputLogEvent(BaseModel):
    """
    Represents a log event.
    """

    timestamp: Optional[Timestamp] = None
    message: Optional[EventMessage] = None
    ingestionTime: Optional[Timestamp] = None


class PolicyDocument(BaseModel):
    __root__: Annotated[str, Field(max_length=5120, min_length=1)]


class RejectedLogEventsInfo(BaseModel):
    """
    Represents the rejected events.
    """

    tooNewLogEventStartIndex: Optional[LogEventIndex] = None
    tooOldLogEventEndIndex: Optional[LogEventIndex] = None
    expiredLogEventEndIndex: Optional[LogEventIndex] = None


class QueryDefinitionString(BaseModel):
    __root__: Annotated[str, Field(max_length=10000, min_length=1)]


class ResourcePolicy(BaseModel):
    """
    A policy enabling one or more entities to put logs to a log group in this account.
    """

    policyName: Optional[PolicyName] = None
    policyDocument: Optional[PolicyDocument] = None
    lastUpdatedTime: Optional[Timestamp] = None


class QueryDefinition(BaseModel):
    """
    This structure contains details about a saved CloudWatch Logs Insights query definition.
    """

    queryDefinitionId: Optional[QueryId] = None
    name: Optional[QueryDefinitionName] = None
    queryString: Optional[QueryDefinitionString] = None
    lastModified: Optional[Timestamp] = None
    logGroupNames: Optional[LogGroupNames] = None


class QueryString(BaseModel):
    __root__: Annotated[str, Field(max_length=10000, min_length=0)]


class QueryInfo(BaseModel):
    """
    Information about one CloudWatch Logs Insights query that matches the request in a <code>DescribeQueries</code> operation.
    """

    queryId: Optional[QueryId] = None
    queryString: Optional[QueryString] = None
    status: Optional[QueryStatus] = None
    createTime: Optional[Timestamp] = None
    logGroupName: Optional[LogGroupName] = None


class StatsValue(DefaultValue):
    pass


class ResultField(BaseModel):
    """
    <p>Contains one field from one log event returned by a CloudWatch Logs Insights query, along with the value of that field.</p> <p>For more information about the fields that are generated by CloudWatch logs, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p>
    """

    field: Optional[FieldModel] = None
    value: Optional[Value] = None


class SearchedLogStream(BaseModel):
    """
    Represents the search status of a log stream.
    """

    logStreamName: Optional[LogStreamName] = None
    searchedCompletely: Optional[LogStreamSearchedCompletely] = None


class SubscriptionFilter(BaseModel):
    """
    Represents a subscription filter.
    """

    filterName: Optional[FilterName] = None
    logGroupName: Optional[LogGroupName] = None
    filterPattern: Optional[FilterPattern] = None
    destinationArn: Optional[DestinationArn] = None
    roleArn: Optional[RoleArn] = None
    distribution: Optional[Distribution] = None
    creationTime: Optional[Timestamp] = None


class TagKey(BaseModel):
    __root__: Annotated[
        str,
        Field(
            max_length=128, min_length=1, regex='^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]+)$'
        ),
    ]


class TagList(BaseModel):
    __root__: Annotated[List[TagKey], Field(min_items=1)]


class TagValue(BaseModel):
    __root__: Annotated[
        str, Field(max_length=256, regex='^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$')
    ]


class TestEventMessages(BaseModel):
    __root__: Annotated[List[EventMessage], Field(max_items=50, min_items=1)]


class Token(Arn):
    pass


class AssociateKmsKeyRequest(BaseModel):
    logGroupName: LogGroupName
    kmsKeyId: KmsKeyId


class CancelExportTaskRequest(BaseModel):
    taskId: ExportTaskId


class CreateExportTaskResponse(BaseModel):
    taskId: Optional[ExportTaskId] = None


class CreateExportTaskRequest(BaseModel):
    taskName: Optional[ExportTaskName] = None
    logGroupName: LogGroupName
    logStreamNamePrefix: Optional[LogStreamName] = None
    from_: Annotated[Timestamp, Field(alias='from')]
    to: Timestamp
    destination: ExportDestinationBucket
    destinationPrefix: Optional[ExportDestinationPrefix] = None


class CreateLogGroupRequest(BaseModel):
    logGroupName: LogGroupName
    kmsKeyId: Optional[KmsKeyId] = None
    tags: Optional[Tags] = None


class CreateLogStreamRequest(BaseModel):
    logGroupName: LogGroupName
    logStreamName: LogStreamName


class DeleteDestinationRequest(BaseModel):
    destinationName: DestinationName


class DeleteLogGroupRequest(BaseModel):
    logGroupName: LogGroupName


class DeleteLogStreamRequest(BaseModel):
    logGroupName: LogGroupName
    logStreamName: LogStreamName


class DeleteMetricFilterRequest(BaseModel):
    logGroupName: LogGroupName
    filterName: FilterName


class DeleteQueryDefinitionResponse(BaseModel):
    success: Optional[Success] = None


class DeleteQueryDefinitionRequest(BaseModel):
    queryDefinitionId: QueryId


class DeleteResourcePolicyRequest(BaseModel):
    policyName: Optional[PolicyName] = None


class DeleteRetentionPolicyRequest(BaseModel):
    logGroupName: LogGroupName


class DeleteSubscriptionFilterRequest(BaseModel):
    logGroupName: LogGroupName
    filterName: FilterName


class DescribeDestinationsRequest(BaseModel):
    DestinationNamePrefix: Optional[DestinationName] = None
    nextToken: Optional[NextToken] = None
    limit: Optional[DescribeLimit] = None


class DescribeExportTasksRequest(BaseModel):
    taskId: Optional[ExportTaskId] = None
    statusCode: Optional[ExportTaskStatusCode] = None
    nextToken: Optional[NextToken] = None
    limit: Optional[DescribeLimit] = None


class DescribeLogGroupsRequest(BaseModel):
    logGroupNamePrefix: Optional[LogGroupName] = None
    nextToken: Optional[NextToken] = None
    limit: Optional[DescribeLimit] = None


class DescribeLogStreamsRequest(BaseModel):
    logGroupName: LogGroupName
    logStreamNamePrefix: Optional[LogStreamName] = None
    orderBy: Optional[OrderBy] = None
    descending: Optional[Descending] = None
    nextToken: Optional[NextToken] = None
    limit: Optional[DescribeLimit] = None


class DescribeMetricFiltersRequest(BaseModel):
    logGroupName: Optional[LogGroupName] = None
    filterNamePrefix: Optional[FilterName] = None
    nextToken: Optional[NextToken] = None
    limit: Optional[DescribeLimit] = None
    metricName: Optional[MetricName] = None
    metricNamespace: Optional[MetricNamespace] = None


class DescribeQueriesRequest(BaseModel):
    logGroupName: Optional[LogGroupName] = None
    status: Optional[QueryStatus] = None
    maxResults: Optional[DescribeQueriesMaxResults] = None
    nextToken: Optional[NextToken] = None


class DescribeQueryDefinitionsRequest(BaseModel):
    queryDefinitionNamePrefix: Optional[QueryDefinitionName] = None
    maxResults: Optional[QueryListMaxResults] = None
    nextToken: Optional[NextToken] = None


class DescribeResourcePoliciesRequest(BaseModel):
    nextToken: Optional[NextToken] = None
    limit: Optional[DescribeLimit] = None


class DescribeSubscriptionFiltersRequest(BaseModel):
    logGroupName: LogGroupName
    filterNamePrefix: Optional[FilterName] = None
    nextToken: Optional[NextToken] = None
    limit: Optional[DescribeLimit] = None


class DisassociateKmsKeyRequest(BaseModel):
    logGroupName: LogGroupName


class FilterLogEventsRequest(BaseModel):
    logGroupName: LogGroupName
    logStreamNames: Optional[InputLogStreamNames] = None
    logStreamNamePrefix: Optional[LogStreamName] = None
    startTime: Optional[Timestamp] = None
    endTime: Optional[Timestamp] = None
    filterPattern: Optional[FilterPattern] = None
    nextToken: Optional[NextToken] = None
    limit: Optional[EventsLimit] = None
    interleaved: Optional[Interleaved] = None


class GetLogEventsRequest(BaseModel):
    logGroupName: LogGroupName
    logStreamName: LogStreamName
    startTime: Optional[Timestamp] = None
    endTime: Optional[Timestamp] = None
    nextToken: Optional[NextToken] = None
    limit: Optional[EventsLimit] = None
    startFromHead: Optional[StartFromHead] = None


class GetLogGroupFieldsRequest(BaseModel):
    logGroupName: LogGroupName
    time: Optional[Timestamp] = None


class GetLogRecordResponse(BaseModel):
    logRecord: Optional[LogRecord] = None


class GetLogRecordRequest(BaseModel):
    logRecordPointer: LogRecordPointer


class GetQueryResultsRequest(BaseModel):
    queryId: QueryId


class ListTagsLogGroupResponse(BaseModel):
    tags: Optional[Tags] = None


class ListTagsLogGroupRequest(BaseModel):
    logGroupName: LogGroupName


class PutDestinationResponse(BaseModel):
    destination: Optional[Destination] = None


class PutDestinationRequest(BaseModel):
    destinationName: DestinationName
    targetArn: TargetArn
    roleArn: RoleArn


class PutDestinationPolicyRequest(BaseModel):
    destinationName: DestinationName
    accessPolicy: AccessPolicy


class PutLogEventsResponse(BaseModel):
    nextSequenceToken: Optional[SequenceToken] = None
    rejectedLogEventsInfo: Optional[RejectedLogEventsInfo] = None


class PutLogEventsRequest(BaseModel):
    logGroupName: LogGroupName
    logStreamName: LogStreamName
    logEvents: InputLogEvents
    sequenceToken: Optional[SequenceToken] = None


class PutQueryDefinitionResponse(BaseModel):
    queryDefinitionId: Optional[QueryId] = None


class PutQueryDefinitionRequest(BaseModel):
    name: QueryDefinitionName
    queryDefinitionId: Optional[QueryId] = None
    logGroupNames: Optional[LogGroupNames] = None
    queryString: QueryDefinitionString


class PutResourcePolicyResponse(BaseModel):
    resourcePolicy: Optional[ResourcePolicy] = None


class PutResourcePolicyRequest(BaseModel):
    policyName: Optional[PolicyName] = None
    policyDocument: Optional[PolicyDocument] = None


class PutRetentionPolicyRequest(BaseModel):
    logGroupName: LogGroupName
    retentionInDays: Days


class PutSubscriptionFilterRequest(BaseModel):
    logGroupName: LogGroupName
    filterName: FilterName
    filterPattern: FilterPattern
    destinationArn: DestinationArn
    roleArn: Optional[RoleArn] = None
    distribution: Optional[Distribution] = None


class StartQueryResponse(BaseModel):
    queryId: Optional[QueryId] = None


class StartQueryRequest(BaseModel):
    logGroupName: Optional[LogGroupName] = None
    logGroupNames: Optional[LogGroupNames] = None
    startTime: Timestamp
    endTime: Timestamp
    queryString: QueryString
    limit: Optional[EventsLimit] = None


class StopQueryResponse(DeleteQueryDefinitionResponse):
    pass


class StopQueryRequest(BaseModel):
    queryId: QueryId


class TagLogGroupRequest(BaseModel):
    logGroupName: LogGroupName
    tags: Tags


class TestMetricFilterResponse(BaseModel):
    matches: Optional[MetricFilterMatches] = None


class TestMetricFilterRequest(BaseModel):
    filterPattern: FilterPattern
    logEventMessages: TestEventMessages


class UntagLogGroupRequest(BaseModel):
    logGroupName: LogGroupName
    tags: TagList


class Destinations(BaseModel):
    __root__: List[Destination]


class LogGroups(BaseModel):
    __root__: List[LogGroup]


class LogStreams(BaseModel):
    __root__: List[LogStream]


class QueryInfoList(BaseModel):
    __root__: List[QueryInfo]


class QueryDefinitionList(BaseModel):
    __root__: List[QueryDefinition]


class ResourcePolicies(BaseModel):
    __root__: List[ResourcePolicy]


class SubscriptionFilters(BaseModel):
    __root__: List[SubscriptionFilter]


class ExportTaskStatus(BaseModel):
    """
    Represents the status of an export task.
    """

    code: Optional[ExportTaskStatusCode] = None
    message: Optional[ExportTaskStatusMessage] = None


class ExportTask(BaseModel):
    """
    Represents an export task.
    """

    taskId: Optional[ExportTaskId] = None
    taskName: Optional[ExportTaskName] = None
    logGroupName: Optional[LogGroupName] = None
    from_: Annotated[Optional[Timestamp], Field(alias='from')] = None
    to: Optional[Timestamp] = None
    destination: Optional[ExportDestinationBucket] = None
    destinationPrefix: Optional[ExportDestinationPrefix] = None
    status: Optional[ExportTaskStatus] = None
    executionInfo: Optional[ExportTaskExecutionInfo] = None


class FilteredLogEvents(BaseModel):
    __root__: List[FilteredLogEvent]


class SearchedLogStreams(BaseModel):
    __root__: List[SearchedLogStream]


class OutputLogEvents(BaseModel):
    __root__: List[OutputLogEvent]


class LogGroupFieldList(BaseModel):
    __root__: List[LogGroupField]


class QueryStatistics(BaseModel):
    """
    Contains the number of log events scanned by the query, the number of log events that matched the query criteria, and the total number of bytes in the log events that were scanned.
    """

    recordsMatched: Optional[StatsValue] = None
    recordsScanned: Optional[StatsValue] = None
    bytesScanned: Optional[StatsValue] = None


class MetricTransformations(BaseModel):
    __root__: Annotated[List[MetricTransformation], Field(max_items=1, min_items=1)]


class MetricFilter(BaseModel):
    """
    Metric filters express how CloudWatch Logs would extract metric observations from ingested log events and transform them into metric data in a CloudWatch metric.
    """

    filterName: Optional[FilterName] = None
    filterPattern: Optional[FilterPattern] = None
    metricTransformations: Optional[MetricTransformations] = None
    creationTime: Optional[Timestamp] = None
    logGroupName: Optional[LogGroupName] = None


class ResultRows(BaseModel):
    __root__: List[ResultField]


class DescribeDestinationsResponse(BaseModel):
    destinations: Optional[Destinations] = None
    nextToken: Optional[NextToken] = None


class DescribeLogGroupsResponse(BaseModel):
    logGroups: Optional[LogGroups] = None
    nextToken: Optional[NextToken] = None


class DescribeLogStreamsResponse(BaseModel):
    logStreams: Optional[LogStreams] = None
    nextToken: Optional[NextToken] = None


class DescribeQueriesResponse(BaseModel):
    queries: Optional[QueryInfoList] = None
    nextToken: Optional[NextToken] = None


class DescribeQueryDefinitionsResponse(BaseModel):
    queryDefinitions: Optional[QueryDefinitionList] = None
    nextToken: Optional[NextToken] = None


class DescribeResourcePoliciesResponse(BaseModel):
    resourcePolicies: Optional[ResourcePolicies] = None
    nextToken: Optional[NextToken] = None


class DescribeSubscriptionFiltersResponse(BaseModel):
    subscriptionFilters: Optional[SubscriptionFilters] = None
    nextToken: Optional[NextToken] = None


class FilterLogEventsResponse(BaseModel):
    events: Optional[FilteredLogEvents] = None
    searchedLogStreams: Optional[SearchedLogStreams] = None
    nextToken: Optional[NextToken] = None


class GetLogEventsResponse(BaseModel):
    events: Optional[OutputLogEvents] = None
    nextForwardToken: Optional[NextToken] = None
    nextBackwardToken: Optional[NextToken] = None


class GetLogGroupFieldsResponse(BaseModel):
    logGroupFields: Optional[LogGroupFieldList] = None


class PutMetricFilterRequest(BaseModel):
    logGroupName: LogGroupName
    filterName: FilterName
    filterPattern: FilterPattern
    metricTransformations: MetricTransformations


class ExportTasks(BaseModel):
    __root__: List[ExportTask]


class MetricFilters(BaseModel):
    __root__: List[MetricFilter]


class QueryResults(BaseModel):
    __root__: List[ResultRows]


class DescribeExportTasksResponse(BaseModel):
    exportTasks: Optional[ExportTasks] = None
    nextToken: Optional[NextToken] = None


class DescribeMetricFiltersResponse(BaseModel):
    metricFilters: Optional[MetricFilters] = None
    nextToken: Optional[NextToken] = None


class GetQueryResultsResponse(BaseModel):
    results: Optional[QueryResults] = None
    statistics: Optional[QueryStatistics] = None
    status: Optional[QueryStatus] = None
