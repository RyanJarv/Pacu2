# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2021-12-31T02:53:01+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Annotated, Any, List, Optional

from pydantic import BaseModel, Field


class InternalServiceErrorException(BaseModel):
    __root__: Any


class InvalidProductCodeException(InternalServiceErrorException):
    pass


class InvalidUsageDimensionException(InternalServiceErrorException):
    pass


class InvalidTagException(InternalServiceErrorException):
    pass


class InvalidUsageAllocationsException(InternalServiceErrorException):
    pass


class InvalidCustomerIdentifierException(InternalServiceErrorException):
    pass


class TimestampOutOfBoundsException(InternalServiceErrorException):
    pass


class ThrottlingException(InternalServiceErrorException):
    pass


class DisabledApiException(InternalServiceErrorException):
    pass


class InvalidEndpointRegionException(InternalServiceErrorException):
    pass


class DuplicateRequestException(InternalServiceErrorException):
    pass


class CustomerNotEntitledException(InternalServiceErrorException):
    pass


class InvalidRegionException(InternalServiceErrorException):
    pass


class InvalidPublicKeyVersionException(InternalServiceErrorException):
    pass


class PlatformNotSupportedException(InternalServiceErrorException):
    pass


class InvalidTokenException(InternalServiceErrorException):
    pass


class ExpiredTokenException(InternalServiceErrorException):
    pass


class AllocatedUsageQuantity(BaseModel):
    __root__: Annotated[int, Field(ge=0.0, le=2147483647.0)]


class ProductCode(BaseModel):
    __root__: Annotated[str, Field(max_length=255, min_length=1, regex='[\\s\\S]+')]


class Boolean(BaseModel):
    __root__: bool


class CustomerIdentifier(ProductCode):
    pass


class Timestamp(BaseModel):
    __root__: datetime


class UsageDimension(ProductCode):
    pass


class UsageQuantity(AllocatedUsageQuantity):
    pass


class String(BaseModel):
    __root__: str


class NonEmptyString(BaseModel):
    __root__: Annotated[str, Field(regex='[\\s\\S]+')]


class Nonce(BaseModel):
    __root__: Annotated[str, Field(max_length=255, regex='[\\s\\S]*')]


class VersionInteger(BaseModel):
    __root__: Annotated[int, Field(ge=1.0)]


class TagKey(BaseModel):
    __root__: Annotated[
        str, Field(max_length=100, min_length=1, regex='^[a-zA-Z0-9+ -=._:\\/@]+$')
    ]


class TagValue(BaseModel):
    __root__: Annotated[
        str, Field(max_length=256, min_length=1, regex='^[a-zA-Z0-9+ -=._:\\/@]+$')
    ]


class Tag(BaseModel):
    """
    Metadata assigned to an allocation. Each tag is made up of a key and a value.
    """

    Key: TagKey
    Value: TagValue


class TagList(BaseModel):
    __root__: Annotated[List[Tag], Field(max_items=5, min_items=1)]


class UsageAllocation(BaseModel):
    """
    <p>Usage allocations allow you to split usage into buckets by tags.</p> <p>Each UsageAllocation indicates the usage quantity for a specific set of tags.</p>
    """

    AllocatedUsageQuantity: AllocatedUsageQuantity
    Tags: Optional[TagList] = None


class UsageRecordResultStatus(Enum):
    Success = 'Success'
    CustomerNotSubscribed = 'CustomerNotSubscribed'
    DuplicateRecord = 'DuplicateRecord'


class MeterUsageResult(BaseModel):
    MeteringRecordId: Optional[String] = None


class RegisterUsageResult(BaseModel):
    PublicKeyRotationTimestamp: Optional[Timestamp] = None
    Signature: Optional[NonEmptyString] = None


class RegisterUsageRequest(BaseModel):
    ProductCode: ProductCode
    PublicKeyVersion: VersionInteger
    Nonce: Optional[Nonce] = None


class ResolveCustomerResult(BaseModel):
    """
    The result of the ResolveCustomer operation. Contains the CustomerIdentifier and product code.
    """

    CustomerIdentifier: Optional[CustomerIdentifier] = None
    ProductCode: Optional[ProductCode] = None


class ResolveCustomerRequest(BaseModel):
    """
    Contains input to the ResolveCustomer operation.
    """

    RegistrationToken: NonEmptyString


class UsageAllocations(BaseModel):
    __root__: Annotated[List[UsageAllocation], Field(max_items=500, min_items=1)]


class UsageRecord(BaseModel):
    """
    <p>A UsageRecord indicates a quantity of usage for a given product, customer, dimension and time.</p> <p>Multiple requests with the same UsageRecords as input will be deduplicated to prevent double charges.</p>
    """

    Timestamp: Timestamp
    CustomerIdentifier: CustomerIdentifier
    Dimension: UsageDimension
    Quantity: Optional[UsageQuantity] = None
    UsageAllocations: Optional[UsageAllocations] = None


class UsageRecordResult(BaseModel):
    """
    A UsageRecordResult indicates the status of a given UsageRecord processed by BatchMeterUsage.
    """

    UsageRecord: Optional[UsageRecord] = None
    MeteringRecordId: Optional[String] = None
    Status: Optional[UsageRecordResultStatus] = None


class MeterUsageRequest(BaseModel):
    ProductCode: ProductCode
    Timestamp: Timestamp
    UsageDimension: UsageDimension
    UsageQuantity: Optional[UsageQuantity] = None
    DryRun: Optional[Boolean] = None
    UsageAllocations: Optional[UsageAllocations] = None


class UsageRecordList(BaseModel):
    __root__: Annotated[List[UsageRecord], Field(max_items=25, min_items=0)]


class UsageRecordResultList(BaseModel):
    __root__: List[UsageRecordResult]


class BatchMeterUsageResult(BaseModel):
    """
    Contains the UsageRecords processed by BatchMeterUsage and any records that have failed due to transient error.
    """

    Results: Optional[UsageRecordResultList] = None
    UnprocessedRecords: Optional[UsageRecordList] = None


class BatchMeterUsageRequest(BaseModel):
    """
    A BatchMeterUsageRequest contains UsageRecords, which indicate quantities of usage within your application.
    """

    UsageRecords: UsageRecordList
    ProductCode: ProductCode
